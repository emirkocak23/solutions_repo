{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # \ud83d\udcd8 Theoretical Foundation \ud83e\uddee Derivation of Projectile Motion from Newton's Laws We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis) \u2733\ufe0f Assumptions: No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\) \ud83d\ude80 1. Equations of Motion Horizontal motion (constant velocity): - Acceleration: \\(a_x = 0\\) - Velocity: \\(v_x = v_0\\cos(\\theta)\\) - Displacement: $$ x(t) = v_0\\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): - Acceleration: \\(a_y = -g\\) - Velocity: \\(v_y = v_0\\sin(\\theta) - gt\\) - Displacement: $$ y(t) = v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ \ud83d\udccf 2. Time of Flight The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\] \u2194\ufe0f 3. Horizontal Range \\(R\\) Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\) \ud83e\uddea 4. Effect of Initial Conditions on Range Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation) \u2705 These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis. \ud83d\udcca Analysis of the Range \ud83d\udd0d 1. Mathematical Relationship Between Range and Angle Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity \ud83d\udd39 Key Observations: Range depends non-linearly on \\(\\theta\\) through \\(\\sin(2\\theta)\\) . The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta=90^\\circ\\) . Therefore, the maximum range occurs at : $$ \\boxed{\\theta=45^\\circ} $$ \u2699\ufe0f 2. Effect of Initial Velocity ( \\(v_0\\) ) From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak. \ud83c\udf0d 3. Effect of Gravitational Acceleration ( \\(g\\) ) Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range . \ud83e\uddd7 4. Launch Height (Advanced) When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] \u26a0\ufe0f Note: Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height. \u2705 Summary Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions. \ud83c\udf10 Practical Applications of Projectile Motion \ud83c\udfaf 1. Real-World Situations Involving Projectile Motion Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields. \ud83c\udf04 2. Effects of Terrain, Drag, and Wind \ud83c\udfde\ufe0f a. Uneven Terrain When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation. \ud83c\udf2c\ufe0f b. Air Resistance (Drag) Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: $$ m\\frac{dv_x}{dt}=-kv_x $$ In vertical direction: $$ m\\frac{dv_y}{dt}=-mg-kv_y $$ These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta. \ud83c\udf2a\ufe0f c. Wind Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\] \ud83e\udde0 3. Adapting the Model To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data. \u2705 Summary Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis. \ud83d\ude80 Implementation: Computational Simulation of Projectile Motion This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions. \ud83d\udccc Objective Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\) \ud83d\udc0d Python Code (Jupyter Notebook Compatible) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height)","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"# \ud83d\udcd8 Theoretical Foundation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-projectile-motion-from-newtons-laws","text":"We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis)","title":"\ud83e\uddee Derivation of Projectile Motion from Newton's Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\)","title":"\u2733\ufe0f Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-equations-of-motion","text":"Horizontal motion (constant velocity): - Acceleration: \\(a_x = 0\\) - Velocity: \\(v_x = v_0\\cos(\\theta)\\) - Displacement: $$ x(t) = v_0\\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): - Acceleration: \\(a_y = -g\\) - Velocity: \\(v_y = v_0\\sin(\\theta) - gt\\) - Displacement: $$ y(t) = v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$","title":"\ud83d\ude80 1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight","text":"The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\]","title":"\ud83d\udccf 2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-horizontal-range-r","text":"Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\)","title":"\u2194\ufe0f 3. Horizontal Range \\(R\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-effect-of-initial-conditions-on-range","text":"Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation)","title":"\ud83e\uddea 4. Effect of Initial Conditions on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-equations-form-the-idealized-model-of-projectile-motion-laying-the-foundation-for-further-numerical-or-simulation-based-analysis","text":"","title":"\u2705 These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"\ud83d\udcca Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-mathematical-relationship-between-range-and-angle","text":"Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity","title":"\ud83d\udd0d 1. Mathematical Relationship Between Range and Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Range depends non-linearly on \\(\\theta\\) through \\(\\sin(2\\theta)\\) . The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta=90^\\circ\\) . Therefore, the maximum range occurs at : $$ \\boxed{\\theta=45^\\circ} $$","title":"\ud83d\udd39 Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effect-of-initial-velocity-v_0","text":"From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak.","title":"\u2699\ufe0f 2. Effect of Initial Velocity (\\(v_0\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration-g","text":"Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range .","title":"\ud83c\udf0d 3. Effect of Gravitational Acceleration (\\(g\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-launch-height-advanced","text":"When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\]","title":"\ud83e\uddd7 4. Launch Height (Advanced)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#note","text":"Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height.","title":"\u26a0\ufe0f Note:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#this-analysis-provides-a-full-picture-of-how-the-range-responds-to-varying-parameters-in-ideal-and-slightly-more-realistic-conditions","text":"","title":"This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"\ud83c\udf10 Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-situations-involving-projectile-motion","text":"Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields.","title":"\ud83c\udfaf 1. Real-World Situations Involving Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effects-of-terrain-drag-and-wind","text":"","title":"\ud83c\udf04 2. Effects of Terrain, Drag, and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-uneven-terrain","text":"When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation.","title":"\ud83c\udfde\ufe0f a. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-air-resistance-drag","text":"Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: $$ m\\frac{dv_x}{dt}=-kv_x $$ In vertical direction: $$ m\\frac{dv_y}{dt}=-mg-kv_y $$ These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta.","title":"\ud83c\udf2c\ufe0f b. Air Resistance (Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#c-wind","text":"Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\]","title":"\ud83c\udf2a\ufe0f c. Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-adapting-the-model","text":"To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data.","title":"\ud83e\udde0 3. Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary_1","text":"Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-computational-simulation-of-projectile-motion","text":"This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions.","title":"\ud83d\ude80 Implementation: Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#objective","text":"Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\)","title":"\ud83d\udccc Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-jupyter-notebook-compatible","text":"","title":"\ud83d\udc0d Python Code (Jupyter Notebook Compatible)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height)","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \u2705 Task Breakdown: Investigating the Dynamics of a Forced Damped Pendulum I. Theoretical Foundation \ud83d\udccc Governing Equation The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(b\\) : Damping coefficient - \\(g\\) : Gravitational acceleration - \\(L\\) : Length of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Frequency of the external driving force \ud83d\udccc Small-Angle Approximation For small oscillations where \\(|\\theta| \\ll 1\\) , we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order nonhomogeneous differential equation and can be analyzed more easily than the original nonlinear equation. \ud83d\udccc Approximate Analytical Solution The general solution consists of: - A homogeneous solution (transient part) depending on initial conditions and damping - A particular solution (steady-state) driven by \\(A\\cos(\\omega t)\\) Assuming a solution of the form: \\[ \\theta(t) = \\Theta \\cos(\\omega t - \\delta) \\] Then, under steady-state conditions, we find: \\[ \\Theta = \\frac{A}{\\sqrt{(g/L - \\omega^2)^2 + (b\\omega)^2}} \\] Where: - \\(\\Theta\\) : Steady-state amplitude - \\(\\delta\\) : Phase lag between driving force and response \ud83d\udccc Resonance Condition Resonance occurs when the denominator is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At this frequency: - The amplitude \\(\\Theta\\) is maximized - Energy input from the driving force matches the natural oscillation frequency - Physical systems can experience large oscillations (resonance phenomenon) II. Analysis of Dynamics \ud83d\udccc Parameter Dependencies Study how varying the following parameters affects the system: Damping coefficient \\(b\\) : Higher \\(b\\) : Faster decay of oscillations, suppresses chaos Lower \\(b\\) : Allows more complex behavior (e.g., quasiperiodicity, chaos) Driving amplitude \\(A\\) : Small \\(A\\) : Linear, predictable motion Large \\(A\\) : Can induce chaotic behavior Driving frequency \\(\\omega\\) : Near resonance: Maximum energy transfer Away from resonance: Damped response \ud83d\udccc Characterizing Motion Regimes Depending on parameters, the pendulum may exhibit: Periodic motion : Oscillations repeat after a fixed time Seen when damping and driving are moderate Quasiperiodic motion : Oscillations never exactly repeat but show structured patterns Multiple incommensurate frequencies involved Chaotic motion : Sensitive dependence on initial conditions Aperiodic and seemingly random Detected using tools like Poincar\u00e9 sections and Lyapunov exponents \ud83d\udccc Physical Interpretations Periodic : Predictable; useful in clocks and timing systems Quasiperiodic : Found in some biological rhythms and coupled oscillators Chaotic : Reflects unpredictability in systems like weather patterns or turbulent flows III. \ud83d\udee0\ufe0f Practical Applications The forced damped pendulum models a variety of real-world systems that involve periodic driving and energy dissipation. Below are some key applications: \ud83d\udd0b 1. Energy Harvesting Devices Piezoelectric or electromagnetic harvesters often model their mechanical components as damped oscillators with forcing. Vibrations in the environment serve as the driving force. Optimal energy harvesting occurs near resonance , where the amplitude of motion is maximized. The governing dynamics resemble: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) $$ Tuning the system to resonate at ambient vibration frequencies enhances energy output. \ud83c\udf09 2. Suspension Bridges and Structural Dynamics Components of bridges or tall buildings behave like forced oscillators under periodic loads (e.g., wind, traffic). The infamous Tacoma Narrows Bridge collapse was due to large-amplitude oscillations caused by wind-driven resonance. Proper damping ( \\(b\\) ) and tuning of natural frequency ( \\(\\sqrt{g/L}\\) ) are crucial in design. \u26a1 3. Driven RLC Circuits Electrical analog of the pendulum: $$ L\\frac{d^2q}{dt^2} + R\\frac{dq}{dt} + \\frac{q}{C} = V_0 \\cos(\\omega t) $$ This is mathematically identical to the forced damped pendulum equation. \\(L\\) , \\(R\\) , and \\(C\\) correspond to inertia , damping , and restoring force , respectively. Used to study resonance , filtering , and signal amplification in electronics. IV. \ud83e\uddee Computational Implementation To study the forced damped pendulum beyond analytical approximations, we implement a numerical simulation using Python. \ud83d\udccc 1. Differential Equation We rewrite the second-order ODE as a system of first-order equations: Let: \\(\\theta = x_1\\) \\(\\dot{\\theta} = x_2\\) Then: \\[ \\begin{cases} \\frac{dx_1}{dt} = x_2 \\\\ \\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t) \\end{cases} \\] \ud83d\udcbb 2. Python Implementation (V\u0131sual) import numpy as np import matplotlib.pyplot as plt # :straight_ruler: Time parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 omega_0 = np.sqrt(g / L) # :orange_heart: New pastel color palette pastel_colors = ['#a2d2ff', '#ffafcc', '#caffbf', '#ffd6a5', '#bdb2ff'] # :repeat: Runge-Kutta 4th Order Method def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # :art: Enhanced Plot Function def plot_pendulum(t, Y, title, color, linestyle='-', marker=None): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(14, 5), facecolor=\"#f7f7f7\") fig.suptitle(title, fontsize=17, fontweight='bold', color=color) # Time series axs[0].plot(t, theta, color=color, linestyle=linestyle, linewidth=2) axs[0].set_title(\"Angular Position Over Time\", fontsize=13) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(r\"$\\theta(t)$ (rad)\") axs[0].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) # Phase portrait axs[1].plot(theta, theta_dot, color=color, linestyle=linestyle, linewidth=1.8) axs[1].set_title(\"Phase Portrait\", fontsize=13) axs[1].set_xlabel(r\"$\\theta$ (rad)\") axs[1].set_ylabel(r\"$\\dot{\\theta}$ (rad/s)\") axs[1].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) plt.tight_layout() plt.show() # :dart: Initial conditions Y0 = np.array([0.3, 0.0]) # :one: Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_pendulum(t, Y, \"1) Simple Pendulum :crescent_moon:\", pastel_colors[0], linestyle='-.') # :two: Damped Pendulum gamma = 0.4 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_pendulum(t, Y, \"2) Damped Pendulum :droplet:\", pastel_colors[1], linestyle='--') # :three: Forced (no damping) A = 1.0 omega = 0.8 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_pendulum(t, Y, \"3) Forced Pendulum :zap:\", pastel_colors[2], linestyle='-') # :four: Forced + Damped gamma = 0.2 def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_pendulum(t, Y, \"4) Forced Damped Pendulum :cyclone:\", pastel_colors[3], linestyle='dashdot') # :five: Chaotic / Resonant Case A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_pendulum(t, Y, \"5) Chaotic Pendulum :fire:\", pastel_colors[4], linestyle='solid') \u2705 Bifurcation Diagram (Optional Advanced) To construct a bifurcation diagram: Vary \\(A\\) or \\(\\omega\\) over a range Plot sampled values of \\(\\theta\\) after transients decay Requires looping over parameters and saving final cycle values \ud83d\udc49 This can be added later for a deeper nonlinear analysis. \u2705 With these tools, you can fully explore the transition to chaos , resonance peaks, and sensitive dependence on parameters and initial conditions. Let me know if you'd like the bifurcation loop or enhancements like interactive sliders!","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-breakdown-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\u2705 Task Breakdown: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#i-theoretical-foundation","text":"","title":"I. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(b\\) : Damping coefficient - \\(g\\) : Gravitational acceleration - \\(L\\) : Length of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Frequency of the external driving force","title":"\ud83d\udccc Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations where \\(|\\theta| \\ll 1\\) , we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order nonhomogeneous differential equation and can be analyzed more easily than the original nonlinear equation.","title":"\ud83d\udccc Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-analytical-solution","text":"The general solution consists of: - A homogeneous solution (transient part) depending on initial conditions and damping - A particular solution (steady-state) driven by \\(A\\cos(\\omega t)\\) Assuming a solution of the form: \\[ \\theta(t) = \\Theta \\cos(\\omega t - \\delta) \\] Then, under steady-state conditions, we find: \\[ \\Theta = \\frac{A}{\\sqrt{(g/L - \\omega^2)^2 + (b\\omega)^2}} \\] Where: - \\(\\Theta\\) : Steady-state amplitude - \\(\\delta\\) : Phase lag between driving force and response","title":"\ud83d\udccc Approximate Analytical Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the denominator is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At this frequency: - The amplitude \\(\\Theta\\) is maximized - Energy input from the driving force matches the natural oscillation frequency - Physical systems can experience large oscillations (resonance phenomenon)","title":"\ud83d\udccc Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#ii-analysis-of-dynamics","text":"","title":"II. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-dependencies","text":"Study how varying the following parameters affects the system: Damping coefficient \\(b\\) : Higher \\(b\\) : Faster decay of oscillations, suppresses chaos Lower \\(b\\) : Allows more complex behavior (e.g., quasiperiodicity, chaos) Driving amplitude \\(A\\) : Small \\(A\\) : Linear, predictable motion Large \\(A\\) : Can induce chaotic behavior Driving frequency \\(\\omega\\) : Near resonance: Maximum energy transfer Away from resonance: Damped response","title":"\ud83d\udccc Parameter Dependencies"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#characterizing-motion-regimes","text":"Depending on parameters, the pendulum may exhibit: Periodic motion : Oscillations repeat after a fixed time Seen when damping and driving are moderate Quasiperiodic motion : Oscillations never exactly repeat but show structured patterns Multiple incommensurate frequencies involved Chaotic motion : Sensitive dependence on initial conditions Aperiodic and seemingly random Detected using tools like Poincar\u00e9 sections and Lyapunov exponents","title":"\ud83d\udccc Characterizing Motion Regimes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretations","text":"Periodic : Predictable; useful in clocks and timing systems Quasiperiodic : Found in some biological rhythms and coupled oscillators Chaotic : Reflects unpredictability in systems like weather patterns or turbulent flows","title":"\ud83d\udccc Physical Interpretations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#iii-practical-applications","text":"The forced damped pendulum models a variety of real-world systems that involve periodic driving and energy dissipation. Below are some key applications:","title":"III. \ud83d\udee0\ufe0f Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Piezoelectric or electromagnetic harvesters often model their mechanical components as damped oscillators with forcing. Vibrations in the environment serve as the driving force. Optimal energy harvesting occurs near resonance , where the amplitude of motion is maximized. The governing dynamics resemble: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) $$ Tuning the system to resonate at ambient vibration frequencies enhances energy output.","title":"\ud83d\udd0b 1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-and-structural-dynamics","text":"Components of bridges or tall buildings behave like forced oscillators under periodic loads (e.g., wind, traffic). The infamous Tacoma Narrows Bridge collapse was due to large-amplitude oscillations caused by wind-driven resonance. Proper damping ( \\(b\\) ) and tuning of natural frequency ( \\(\\sqrt{g/L}\\) ) are crucial in design.","title":"\ud83c\udf09 2. Suspension Bridges and Structural Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-driven-rlc-circuits","text":"Electrical analog of the pendulum: $$ L\\frac{d^2q}{dt^2} + R\\frac{dq}{dt} + \\frac{q}{C} = V_0 \\cos(\\omega t) $$ This is mathematically identical to the forced damped pendulum equation. \\(L\\) , \\(R\\) , and \\(C\\) correspond to inertia , damping , and restoring force , respectively. Used to study resonance , filtering , and signal amplification in electronics.","title":"\u26a1 3. Driven RLC Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#iv-computational-implementation","text":"To study the forced damped pendulum beyond analytical approximations, we implement a numerical simulation using Python.","title":"IV. \ud83e\uddee Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-differential-equation","text":"We rewrite the second-order ODE as a system of first-order equations: Let: \\(\\theta = x_1\\) \\(\\dot{\\theta} = x_2\\) Then: \\[ \\begin{cases} \\frac{dx_1}{dt} = x_2 \\\\ \\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t) \\end{cases} \\]","title":"\ud83d\udccc 1. Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-implementation-vsual","text":"import numpy as np import matplotlib.pyplot as plt # :straight_ruler: Time parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 omega_0 = np.sqrt(g / L) # :orange_heart: New pastel color palette pastel_colors = ['#a2d2ff', '#ffafcc', '#caffbf', '#ffd6a5', '#bdb2ff'] # :repeat: Runge-Kutta 4th Order Method def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # :art: Enhanced Plot Function def plot_pendulum(t, Y, title, color, linestyle='-', marker=None): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(14, 5), facecolor=\"#f7f7f7\") fig.suptitle(title, fontsize=17, fontweight='bold', color=color) # Time series axs[0].plot(t, theta, color=color, linestyle=linestyle, linewidth=2) axs[0].set_title(\"Angular Position Over Time\", fontsize=13) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(r\"$\\theta(t)$ (rad)\") axs[0].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) # Phase portrait axs[1].plot(theta, theta_dot, color=color, linestyle=linestyle, linewidth=1.8) axs[1].set_title(\"Phase Portrait\", fontsize=13) axs[1].set_xlabel(r\"$\\theta$ (rad)\") axs[1].set_ylabel(r\"$\\dot{\\theta}$ (rad/s)\") axs[1].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) plt.tight_layout() plt.show() # :dart: Initial conditions Y0 = np.array([0.3, 0.0]) # :one: Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_pendulum(t, Y, \"1) Simple Pendulum :crescent_moon:\", pastel_colors[0], linestyle='-.') # :two: Damped Pendulum gamma = 0.4 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_pendulum(t, Y, \"2) Damped Pendulum :droplet:\", pastel_colors[1], linestyle='--') # :three: Forced (no damping) A = 1.0 omega = 0.8 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_pendulum(t, Y, \"3) Forced Pendulum :zap:\", pastel_colors[2], linestyle='-') # :four: Forced + Damped gamma = 0.2 def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_pendulum(t, Y, \"4) Forced Damped Pendulum :cyclone:\", pastel_colors[3], linestyle='dashdot') # :five: Chaotic / Resonant Case A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_pendulum(t, Y, \"5) Chaotic Pendulum :fire:\", pastel_colors[4], linestyle='solid')","title":"\ud83d\udcbb 2. Python Implementation (V\u0131sual)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram-optional-advanced","text":"To construct a bifurcation diagram: Vary \\(A\\) or \\(\\omega\\) over a range Plot sampled values of \\(\\theta\\) after transients decay Requires looping over parameters and saving final cycle values \ud83d\udc49 This can be added later for a deeper nonlinear analysis. \u2705 With these tools, you can fully explore the transition to chaos , resonance peaks, and sensitive dependence on parameters and initial conditions. Let me know if you'd like the bifurcation loop or enhancements like interactive sliders!","title":"\u2705 Bifurcation Diagram (Optional Advanced)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius \ud83e\udde0 Derivation of Kepler's Third Law for Circular Orbits Kepler's Third Law states: The square of the orbital period ( \\(T\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits , the derivation proceeds from Newton\u2019s Law of Gravitation and centripetal force : 1. Equating Gravitational and Centripetal Forces Gravitational force: \\[ F_g = \\frac{GMm}{r^2} \\] Centripetal force: \\[ F_c = \\frac{mv^2}{r} \\] Equating both: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Mass \\(m\\) cancels: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] Solve for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] 2. Orbital Period from Velocity The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] \u2705 Final Result (Kepler\u2019s Third Law): \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\Rightarrow T^2 \\propto r^3 \\] \ud83c\udf0c Significance of the \\(T^2 \\propto r^3\\) Relationship Helps determine distances of planets from stars. Enables estimation of masses of celestial bodies. Crucial in calculating satellite orbits , spacecraft trajectories . Valid for any object orbiting under gravity in a central field. \ud83c\udf0d Real-World Applications Examples where Kepler's Law applies: Moon around Earth \\(r = 3.84 \\times 10^8\\) m, \\(T = 27.3\\) days Planets in Solar System Approximate relation holds: \\(T^2 \\propto r^3\\) \\(T\\) in Earth years, \\(r\\) in AU \ud83e\uddea Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) \u2014 from 0.3 AU to 30 AU radii = np.linspace(0.3, 30, 300) * 1.496e11 # Calculate orbital periods using Kepler's Third Law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Prepare figure plt.figure(figsize=(10, 6)) colors = plt.cm.plasma(np.linspace(0, 1, len(radii))) # Gradient color map # Plot with colorful dots plt.scatter(radii**3, T**2, c=colors, s=10, edgecolor='black', linewidth=0.2, alpha=0.8, label=r'$\\mathbf{T^2 \\propto r^3}$') # Real Solar System planets (approximate data) planet_data = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86), 'Saturn': (9.58, 29.46), 'Uranus': (19.22, 84.01), 'Neptune': (30.05, 164.8) } # Plot planet points for planet, (r_au, T_years) in planet_data.items(): r3 = (r_au * 1.496e11) ** 3 T2 = (T_years * 365.25 * 24 * 3600) ** 2 plt.scatter(r3, T2, color='black', s=40, marker='o', label=planet) plt.annotate(planet, (r3, T2), textcoords=\"offset points\", xytext=(5, 5), fontsize=8) # Axis labels plt.xlabel(r'$r^3 \\, (m^3)$', fontsize=12) plt.ylabel(r'$T^2 \\, (s^2)$', fontsize=12) plt.title('\ud83c\udf0d Kepler\\'s Third Law with Planetary Orbits', fontsize=14) plt.grid(True, linestyle='--', alpha=0.5) # Custom legend handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) # Remove duplicates plt.legend(by_label.values(), by_label.keys(), fontsize=8, loc='upper left') plt.tight_layout() plt.show() \ud83d\udcd8 Problem 2: Escape Velocities and Cosmic Velocities \ud83e\udde0 Defining the First, Second, and Third Cosmic Velocities The cosmic velocities are the speeds needed to escape or orbit a celestial body. There are three important cosmic velocities: First Cosmic Velocity : The velocity needed to orbit a celestial body in a circular orbit at the surface level. This is also called the orbital velocity . Formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., Earth, Mars, etc.), - \\(r\\) is the radius of the celestial body. Second Cosmic Velocity : The velocity needed to escape the gravitational pull of a celestial body. This is also known as the escape velocity . Formula: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(r\\) is the distance from the center of the celestial body, - \\(M\\) is the mass of the celestial body, - \\(G\\) is the gravitational constant. Third Cosmic Velocity : The velocity required to escape the gravitational influence of the entire solar system or any star system. This velocity is needed to break free from the central star's gravitational pull. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\] \ud83d\udd2c Derivation of Each Velocity 1. First Cosmic Velocity (Orbital Velocity) The orbital velocity is the velocity needed for an object to move in a stable circular orbit around a celestial body. The centripetal force required for a circular orbit is provided by the gravitational force: \\[ F_c = \\frac{mv^2}{r}, \\quad F_g = \\frac{GMm}{r^2} \\] Equating the forces: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity (Escape Velocity) The escape velocity is the speed needed to break free from the gravitational pull of a celestial body, without any additional propulsion. The energy needed to escape is equal to the kinetic energy required to overcome the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity The third cosmic velocity is the velocity needed to escape the gravitational influence of the entire solar system or any other star system. It is derived from the concept of gravitational potential energy of the system. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\] \ud83d\udd0d Parameters Affecting the Cosmic Velocities The cosmic velocities depend on two key parameters: Mass ( \\(M\\) ) of the celestial body : Larger masses increase the required velocities. Radius ( \\(r\\) ) of the celestial body : Larger radii (i.e., larger distances) reduce the required velocities. \ud83c\udf0d Calculating Escape and Orbital Velocities for Earth, Mars, and Jupiter Let's calculate the escape and orbital velocities for Earth, Mars, and Jupiter using the formulas derived above. The constants we'll use are: Gravitational constant ( \\(G\\) ) = \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Mass and radius of planets (approximations): Earth: \\(M_\\text{Earth} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Earth} = 6.371 \\times 10^6 \\, \\text{m}\\) Mars: \\(M_\\text{Mars} = 0.64171 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Mars} = 3.396 \\times 10^6 \\, \\text{m}\\) Jupiter: \\(M_\\text{Jupiter} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(r_\\text{Jupiter} = 6.991 \\times 10^7 \\, \\text{m}\\) \ud83e\uddea Python Code for Calculations and Visualization import numpy as np import matplotlib.pyplot as plt # Constants AU = 1.496e11 # 1 Astronomical Unit in meters (average Earth-Sun distance) radius = AU # Create theta array for orbit (0 to 2\u03c0) theta = np.linspace(0, 2 * np.pi, 1000) # Parametric equations for the circular orbit x = radius * np.cos(theta) y = radius * np.sin(theta) # Plotting plt.figure(figsize=(8, 8)) plt.plot(x, y, color='mediumseagreen', linewidth=2.5, label=f'Orbit Radius = {radius/1e6:.0f} km') plt.scatter(0, 0, color='gold', s=300, label='\u2600\ufe0f Sun Position', edgecolors='darkorange', linewidths=2, zorder=5) # Styling plt.title('\ud83c\udf0d Orbital Path around the Sun', fontsize=16, weight='bold') plt.xlabel('x (m)', fontsize=12) plt.ylabel('y (m)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.axis('equal') plt.legend(loc='upper center', fontsize=10, frameon=True, shadow=True) # Optional: dark background (uncomment if you want it) # plt.style.use('dark_background') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"\ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"Kepler's Third Law states: The square of the orbital period ( \\(T\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits , the derivation proceeds from Newton\u2019s Law of Gravitation and centripetal force :","title":"\ud83e\udde0 Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-equating-gravitational-and-centripetal-forces","text":"Gravitational force: \\[ F_g = \\frac{GMm}{r^2} \\] Centripetal force: \\[ F_c = \\frac{mv^2}{r} \\] Equating both: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Mass \\(m\\) cancels: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] Solve for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\]","title":"1. Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-orbital-period-from-velocity","text":"The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\]","title":"2. Orbital Period from Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-result-keplers-third-law","text":"\\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\Rightarrow T^2 \\propto r^3 \\]","title":"\u2705 Final Result (Kepler\u2019s Third Law):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#significance-of-the-t2-propto-r3-relationship","text":"Helps determine distances of planets from stars. Enables estimation of masses of celestial bodies. Crucial in calculating satellite orbits , spacecraft trajectories . Valid for any object orbiting under gravity in a central field.","title":"\ud83c\udf0c Significance of the \\(T^2 \\propto r^3\\) Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-applications","text":"Examples where Kepler's Law applies: Moon around Earth \\(r = 3.84 \\times 10^8\\) m, \\(T = 27.3\\) days Planets in Solar System Approximate relation holds: \\(T^2 \\propto r^3\\) \\(T\\) in Earth years, \\(r\\) in AU","title":"\ud83c\udf0d Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) \u2014 from 0.3 AU to 30 AU radii = np.linspace(0.3, 30, 300) * 1.496e11 # Calculate orbital periods using Kepler's Third Law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Prepare figure plt.figure(figsize=(10, 6)) colors = plt.cm.plasma(np.linspace(0, 1, len(radii))) # Gradient color map # Plot with colorful dots plt.scatter(radii**3, T**2, c=colors, s=10, edgecolor='black', linewidth=0.2, alpha=0.8, label=r'$\\mathbf{T^2 \\propto r^3}$') # Real Solar System planets (approximate data) planet_data = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86), 'Saturn': (9.58, 29.46), 'Uranus': (19.22, 84.01), 'Neptune': (30.05, 164.8) } # Plot planet points for planet, (r_au, T_years) in planet_data.items(): r3 = (r_au * 1.496e11) ** 3 T2 = (T_years * 365.25 * 24 * 3600) ** 2 plt.scatter(r3, T2, color='black', s=40, marker='o', label=planet) plt.annotate(planet, (r3, T2), textcoords=\"offset points\", xytext=(5, 5), fontsize=8) # Axis labels plt.xlabel(r'$r^3 \\, (m^3)$', fontsize=12) plt.ylabel(r'$T^2 \\, (s^2)$', fontsize=12) plt.title('\ud83c\udf0d Kepler\\'s Third Law with Planetary Orbits', fontsize=14) plt.grid(True, linestyle='--', alpha=0.5) # Custom legend handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) # Remove duplicates plt.legend(by_label.values(), by_label.keys(), fontsize=8, loc='upper left') plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\udcd8 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#defining-the-first-second-and-third-cosmic-velocities","text":"The cosmic velocities are the speeds needed to escape or orbit a celestial body. There are three important cosmic velocities: First Cosmic Velocity : The velocity needed to orbit a celestial body in a circular orbit at the surface level. This is also called the orbital velocity . Formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., Earth, Mars, etc.), - \\(r\\) is the radius of the celestial body. Second Cosmic Velocity : The velocity needed to escape the gravitational pull of a celestial body. This is also known as the escape velocity . Formula: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(r\\) is the distance from the center of the celestial body, - \\(M\\) is the mass of the celestial body, - \\(G\\) is the gravitational constant. Third Cosmic Velocity : The velocity required to escape the gravitational influence of the entire solar system or any star system. This velocity is needed to break free from the central star's gravitational pull. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\]","title":"\ud83e\udde0 Defining the First, Second, and Third Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-each-velocity","text":"","title":"\ud83d\udd2c Derivation of Each Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-first-cosmic-velocity-orbital-velocity","text":"The orbital velocity is the velocity needed for an object to move in a stable circular orbit around a celestial body. The centripetal force required for a circular orbit is provided by the gravitational force: \\[ F_c = \\frac{mv^2}{r}, \\quad F_g = \\frac{GMm}{r^2} \\] Equating the forces: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-second-cosmic-velocity-escape-velocity","text":"The escape velocity is the speed needed to break free from the gravitational pull of a celestial body, without any additional propulsion. The energy needed to escape is equal to the kinetic energy required to overcome the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-third-cosmic-velocity","text":"The third cosmic velocity is the velocity needed to escape the gravitational influence of the entire solar system or any other star system. It is derived from the concept of gravitational potential energy of the system. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\]","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#parameters-affecting-the-cosmic-velocities","text":"The cosmic velocities depend on two key parameters: Mass ( \\(M\\) ) of the celestial body : Larger masses increase the required velocities. Radius ( \\(r\\) ) of the celestial body : Larger radii (i.e., larger distances) reduce the required velocities.","title":"\ud83d\udd0d Parameters Affecting the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-escape-and-orbital-velocities-for-earth-mars-and-jupiter","text":"Let's calculate the escape and orbital velocities for Earth, Mars, and Jupiter using the formulas derived above. The constants we'll use are: Gravitational constant ( \\(G\\) ) = \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Mass and radius of planets (approximations): Earth: \\(M_\\text{Earth} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Earth} = 6.371 \\times 10^6 \\, \\text{m}\\) Mars: \\(M_\\text{Mars} = 0.64171 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Mars} = 3.396 \\times 10^6 \\, \\text{m}\\) Jupiter: \\(M_\\text{Jupiter} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(r_\\text{Jupiter} = 6.991 \\times 10^7 \\, \\text{m}\\)","title":"\ud83c\udf0d Calculating Escape and Orbital Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-calculations-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants AU = 1.496e11 # 1 Astronomical Unit in meters (average Earth-Sun distance) radius = AU # Create theta array for orbit (0 to 2\u03c0) theta = np.linspace(0, 2 * np.pi, 1000) # Parametric equations for the circular orbit x = radius * np.cos(theta) y = radius * np.sin(theta) # Plotting plt.figure(figsize=(8, 8)) plt.plot(x, y, color='mediumseagreen', linewidth=2.5, label=f'Orbit Radius = {radius/1e6:.0f} km') plt.scatter(0, 0, color='gold', s=300, label='\u2600\ufe0f Sun Position', edgecolors='darkorange', linewidths=2, zorder=5) # Styling plt.title('\ud83c\udf0d Orbital Path around the Sun', fontsize=16, weight='bold') plt.xlabel('x (m)', fontsize=12) plt.ylabel('y (m)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.axis('equal') plt.legend(loc='upper center', fontsize=10, frameon=True, shadow=True) # Optional: dark background (uncomment if you want it) # plt.style.use('dark_background') plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Code for Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Define the Concepts \ud83d\ude80 First Cosmic Velocity \u2014 Orbital Velocity Definition : The minimum velocity required for a body to stay in a stable circular orbit around a celestial object (like Earth) without propulsion. Physical Meaning : At this speed, the gravitational pull provides exactly the centripetal force needed for circular motion. A satellite moving at this speed remains in orbit just above the surface. \ud83c\udf0d Second Cosmic Velocity \u2014 Escape Velocity Definition : The minimum velocity needed to break free from the gravitational field of a celestial body without further propulsion. Physical Meaning : If a spacecraft reaches this velocity, it will escape the planet's gravity and not return, unless acted upon by another force. It is independent of the direction of launch (ignoring atmosphere and rotation). \ud83c\udf0c Third Cosmic Velocity \u2014 Interstellar Escape Velocity Definition : The minimum velocity required to escape the gravitational influence of the entire star system (e.g., Sun + planets). Physical Meaning : This is the speed needed to leave the solar system entirely . Used in planning interstellar missions like Voyager 1 & 2 . \ud83d\udcd0 Mathematical Analysis 1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity) Derived from equating centripetal force and gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Parameters : \\(G\\) : Gravitational constant \\(r\\) : Radius from center of mass (typically planet\u2019s radius for low orbit) 2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity) Derived from conservation of energy: Total mechanical energy at escape = 0 (kinetic = gravitational potential energy) \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}} \\] Note : \\(v_2 = \\sqrt{2} \\cdot v_1\\) 3\ufe0f\u20e3 Third Cosmic Velocity (Interstellar Escape) More complex derivation involving solar system dynamics. Escape velocity from Sun at Earth's orbit: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] If starting from Earth, subtract Earth's orbital velocity (~29.78 km/s): \\[ v_{3,\\text{from Earth}} = v_3 - v_{\\text{Earth orbit}} \\] \ud83d\udcca Parameter Effects Mass ( \\(M\\) ) : Directly increases velocity \u2014 more massive body requires more speed to escape. Radius ( \\(r\\) ) : Inversely proportional \u2014 closer to center means stronger gravity, hence higher velocity. Gravitational constant ( \\(G\\) ) : A fixed universal constant. \ud83d\udd01 Comparison Table Velocity Type Formula Depends On First Cosmic ( \\(v_1\\) ) \\(\\sqrt{\\frac{GM}{r}}\\) Mass, Radius Second Cosmic ( \\(v_2\\) ) \\(\\sqrt{\\frac{2GM}{r}}\\) Mass, Radius Third Cosmic ( \\(v_3\\) ) \\(\\sqrt{\\frac{2GM_{\\odot}}{r}}\\) Sun's Mass, Distance \ud83c\udf0c Cosmic Velocities \u2013 Calculations and Visualizations \ud83c\udfaf Objective Calculate the first , second , and third cosmic velocities for the following celestial bodies: Earth Mars Jupiter Create visualizations to compare these velocities across planets. \ud83e\uddee Formulas Used Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}\\) 1\ufe0f\u20e3 First Cosmic Velocity \u2013 Orbital Velocity Equation: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ 2\ufe0f\u20e3 Second Cosmic Velocity \u2013 Escape Velocity Equation: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ 3\ufe0f\u20e3 Third Cosmic Velocity \u2013 Interstellar Escape (from Sun) Equation: $$ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R_{\\text{orbit}}}} $$ \ud83e\udde0 Parameters \\(M\\) : Mass of the planet \\(r\\) : Radius of the planet \\(M_{\\odot}\\) : Mass of the Sun \\(R_{\\text{orbit}}\\) : Distance from Sun (orbital radius of the planet) \ud83d\udc0d Python-Visual Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # kg # Planetary data planets = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'orbit_radius': 1.496e11}, 'Mars': {'mass': 6.4171e23, 'radius': 3.3895e6, 'orbit_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'orbit_radius': 7.785e11} } # Storage planet_names = [] v1_values = [] v2_values = [] v3_values = [] # Calculation for name, data in planets.items(): M = data['mass'] r = data['radius'] R_orbit = data['orbit_radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) v3 = np.sqrt(2 * G * M_sun / R_orbit) planet_names.append(name) v1_values.append(v1 / 1000) # km/s v2_values.append(v2 / 1000) v3_values.append(v3 / 1000) # Set up better visualization fig, ax = plt.subplots(figsize=(10, 6)) ax.set_facecolor('whitesmoke') colors = ['deepskyblue', 'orange', 'limegreen'] x_positions = np.arange(len(planet_names)) * 3 # spacing between planets # Plot each velocity as a vertical line (\"tower\") for i, name in enumerate(planet_names): xpos = x_positions[i] ax.vlines(xpos - 0.5, 0, v1_values[i], color=colors[0], lw=6, label='1st Cosmic' if i == 0 else \"\") ax.vlines(xpos, 0, v2_values[i], color=colors[1], lw=6, label='2nd Cosmic' if i == 0 else \"\") ax.vlines(xpos + 0.5, 0, v3_values[i], color=colors[2], lw=6, label='3rd Cosmic' if i == 0 else \"\") # Add labels ax.text(xpos - 0.5, v1_values[i] + 0.3, f\"{v1_values[i]:.1f}\", ha='center', color=colors[0], fontsize=9) ax.text(xpos, v2_values[i] + 0.3, f\"{v2_values[i]:.1f}\", ha='center', color=colors[1], fontsize=9) ax.text(xpos + 0.5, v3_values[i] + 0.3, f\"{v3_values[i]:.1f}\", ha='center', color=colors[2], fontsize=9) # Planet label ax.text(xpos, -1.5, name, ha='center', fontsize=12, fontweight='bold') # Aesthetics ax.set_xlim(-1, x_positions[-1] + 2) ax.set_ylim(0, max(v2_values) + 5) ax.set_ylabel(\"Velocity (km/s)\", fontsize=12) ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\", fontsize=14, fontweight='bold') ax.legend(loc='upper right') ax.grid(True, axis='y', linestyle='--', alpha=0.5) plt.tight_layout() plt.show() \ud83d\ude80 Discussion: Importance of Cosmic Velocities in Space Missions Understanding cosmic velocities is critical in planning space missions. The three main velocities \u2014 first , second , and third cosmic velocities \u2014 define key thresholds in spaceflight dynamics. \ud83c\udf00 First Cosmic Velocity ( \\(v_1\\) ): Orbital Velocity Definition : Minimum velocity needed to place a satellite into stable circular orbit around a planet. Equation : \\( \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) where: \\(G\\) = gravitational constant \\(M\\) = mass of the planet \\(r\\) = radius from the planet's center Use case : Placing satellites like the ISS (International Space Station) into low Earth orbit . Used by companies like SpaceX and NASA for communication and Earth observation satellites. \ud83d\ude80 Second Cosmic Velocity ( \\(v_2\\) ): Escape Velocity Definition : Minimum velocity to completely escape a planet's gravitational field. Equation : \\( \\(v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}}\\) \\) Use case : Used in interplanetary missions , such as Mars rovers (Perseverance, Curiosity) . Apollo missions had to reach this speed to leave Earth and travel to the Moon. \ud83c\udf0c Third Cosmic Velocity ( \\(v_3\\) ): Interstellar Escape Velocity Definition : Minimum velocity to escape the gravitational pull of the Sun from Earth\u2019s orbit. Equation : \\( \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}}\\) \\) where: \\(M_{\\odot}\\) = mass of the Sun \\(R\\) = orbital radius (e.g., 1 AU for Earth) Use case : Missions like Voyager 1 and Voyager 2 (launched in 1977) exceeded this speed. These probes are now traveling through interstellar space , having exited the heliosphere. \ud83d\udef0\ufe0f Summary of Practical Implications \\(v_1\\) : Required to maintain satellite orbits . \\(v_2\\) : Required to conduct planetary transfers or leave planets. \\(v_3\\) : Required to exit the Solar System and explore interstellar space. \ud83c\udf0d Real-World Examples Mission Velocity Used Purpose ISS Launches (e.g., SpaceX) \\(v_1\\) Satellite orbiting Earth Mars Rovers (Perseverance) \\(v_2\\) Escape Earth to reach Mars Voyager 1/2 (NASA, 1977) \\(v_3\\) Escape the Solar System \ud83d\udca1 These concepts not only define theoretical thresholds but also directly inform mission planning, fuel budgeting, and spacecraft engineering .","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#define-the-concepts","text":"","title":"Define the Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum velocity required for a body to stay in a stable circular orbit around a celestial object (like Earth) without propulsion. Physical Meaning : At this speed, the gravitational pull provides exactly the centripetal force needed for circular motion. A satellite moving at this speed remains in orbit just above the surface.","title":"\ud83d\ude80 First Cosmic Velocity \u2014 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : The minimum velocity needed to break free from the gravitational field of a celestial body without further propulsion. Physical Meaning : If a spacecraft reaches this velocity, it will escape the planet's gravity and not return, unless acted upon by another force. It is independent of the direction of launch (ignoring atmosphere and rotation).","title":"\ud83c\udf0d Second Cosmic Velocity \u2014 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape-velocity","text":"Definition : The minimum velocity required to escape the gravitational influence of the entire star system (e.g., Sun + planets). Physical Meaning : This is the speed needed to leave the solar system entirely . Used in planning interstellar missions like Voyager 1 & 2 .","title":"\ud83c\udf0c Third Cosmic Velocity \u2014 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-analysis","text":"","title":"\ud83d\udcd0 Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"Derived from equating centripetal force and gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Parameters : \\(G\\) : Gravitational constant \\(r\\) : Radius from center of mass (typically planet\u2019s radius for low orbit)","title":"1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"Derived from conservation of energy: Total mechanical energy at escape = 0 (kinetic = gravitational potential energy) \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}} \\] Note : \\(v_2 = \\sqrt{2} \\cdot v_1\\)","title":"2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-escape","text":"More complex derivation involving solar system dynamics. Escape velocity from Sun at Earth's orbit: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] If starting from Earth, subtract Earth's orbital velocity (~29.78 km/s): \\[ v_{3,\\text{from Earth}} = v_3 - v_{\\text{Earth orbit}} \\]","title":"3\ufe0f\u20e3 Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameter-effects","text":"Mass ( \\(M\\) ) : Directly increases velocity \u2014 more massive body requires more speed to escape. Radius ( \\(r\\) ) : Inversely proportional \u2014 closer to center means stronger gravity, hence higher velocity. Gravitational constant ( \\(G\\) ) : A fixed universal constant.","title":"\ud83d\udcca Parameter Effects"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-table","text":"Velocity Type Formula Depends On First Cosmic ( \\(v_1\\) ) \\(\\sqrt{\\frac{GM}{r}}\\) Mass, Radius Second Cosmic ( \\(v_2\\) ) \\(\\sqrt{\\frac{2GM}{r}}\\) Mass, Radius Third Cosmic ( \\(v_3\\) ) \\(\\sqrt{\\frac{2GM_{\\odot}}{r}}\\) Sun's Mass, Distance","title":"\ud83d\udd01 Comparison Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-calculations-and-visualizations","text":"","title":"\ud83c\udf0c Cosmic Velocities \u2013 Calculations and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#objective","text":"Calculate the first , second , and third cosmic velocities for the following celestial bodies: Earth Mars Jupiter Create visualizations to compare these velocities across planets.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_2/#formulas-used","text":"Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}\\)","title":"\ud83e\uddee Formulas Used"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity_1","text":"Equation: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$","title":"1\ufe0f\u20e3 First Cosmic Velocity \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity_1","text":"Equation: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$","title":"2\ufe0f\u20e3 Second Cosmic Velocity \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-escape-from-sun","text":"Equation: $$ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R_{\\text{orbit}}}} $$","title":"3\ufe0f\u20e3 Third Cosmic Velocity \u2013 Interstellar Escape (from Sun)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"\\(M\\) : Mass of the planet \\(r\\) : Radius of the planet \\(M_{\\odot}\\) : Mass of the Sun \\(R_{\\text{orbit}}\\) : Distance from Sun (orbital radius of the planet)","title":"\ud83e\udde0 Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-visual-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # kg # Planetary data planets = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'orbit_radius': 1.496e11}, 'Mars': {'mass': 6.4171e23, 'radius': 3.3895e6, 'orbit_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'orbit_radius': 7.785e11} } # Storage planet_names = [] v1_values = [] v2_values = [] v3_values = [] # Calculation for name, data in planets.items(): M = data['mass'] r = data['radius'] R_orbit = data['orbit_radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) v3 = np.sqrt(2 * G * M_sun / R_orbit) planet_names.append(name) v1_values.append(v1 / 1000) # km/s v2_values.append(v2 / 1000) v3_values.append(v3 / 1000) # Set up better visualization fig, ax = plt.subplots(figsize=(10, 6)) ax.set_facecolor('whitesmoke') colors = ['deepskyblue', 'orange', 'limegreen'] x_positions = np.arange(len(planet_names)) * 3 # spacing between planets # Plot each velocity as a vertical line (\"tower\") for i, name in enumerate(planet_names): xpos = x_positions[i] ax.vlines(xpos - 0.5, 0, v1_values[i], color=colors[0], lw=6, label='1st Cosmic' if i == 0 else \"\") ax.vlines(xpos, 0, v2_values[i], color=colors[1], lw=6, label='2nd Cosmic' if i == 0 else \"\") ax.vlines(xpos + 0.5, 0, v3_values[i], color=colors[2], lw=6, label='3rd Cosmic' if i == 0 else \"\") # Add labels ax.text(xpos - 0.5, v1_values[i] + 0.3, f\"{v1_values[i]:.1f}\", ha='center', color=colors[0], fontsize=9) ax.text(xpos, v2_values[i] + 0.3, f\"{v2_values[i]:.1f}\", ha='center', color=colors[1], fontsize=9) ax.text(xpos + 0.5, v3_values[i] + 0.3, f\"{v3_values[i]:.1f}\", ha='center', color=colors[2], fontsize=9) # Planet label ax.text(xpos, -1.5, name, ha='center', fontsize=12, fontweight='bold') # Aesthetics ax.set_xlim(-1, x_positions[-1] + 2) ax.set_ylim(0, max(v2_values) + 5) ax.set_ylabel(\"Velocity (km/s)\", fontsize=12) ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\", fontsize=14, fontweight='bold') ax.legend(loc='upper right') ax.grid(True, axis='y', linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python-Visual Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-importance-of-cosmic-velocities-in-space-missions","text":"Understanding cosmic velocities is critical in planning space missions. The three main velocities \u2014 first , second , and third cosmic velocities \u2014 define key thresholds in spaceflight dynamics.","title":"\ud83d\ude80 Discussion: Importance of Cosmic Velocities in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1-orbital-velocity","text":"Definition : Minimum velocity needed to place a satellite into stable circular orbit around a planet. Equation : \\( \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) where: \\(G\\) = gravitational constant \\(M\\) = mass of the planet \\(r\\) = radius from the planet's center Use case : Placing satellites like the ISS (International Space Station) into low Earth orbit . Used by companies like SpaceX and NASA for communication and Earth observation satellites.","title":"\ud83c\udf00 First Cosmic Velocity (\\(v_1\\)): Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2-escape-velocity","text":"Definition : Minimum velocity to completely escape a planet's gravitational field. Equation : \\( \\(v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}}\\) \\) Use case : Used in interplanetary missions , such as Mars rovers (Perseverance, Curiosity) . Apollo missions had to reach this speed to leave Earth and travel to the Moon.","title":"\ud83d\ude80 Second Cosmic Velocity (\\(v_2\\)): Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3-interstellar-escape-velocity","text":"Definition : Minimum velocity to escape the gravitational pull of the Sun from Earth\u2019s orbit. Equation : \\( \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}}\\) \\) where: \\(M_{\\odot}\\) = mass of the Sun \\(R\\) = orbital radius (e.g., 1 AU for Earth) Use case : Missions like Voyager 1 and Voyager 2 (launched in 1977) exceeded this speed. These probes are now traveling through interstellar space , having exited the heliosphere.","title":"\ud83c\udf0c Third Cosmic Velocity (\\(v_3\\)): Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-of-practical-implications","text":"\\(v_1\\) : Required to maintain satellite orbits . \\(v_2\\) : Required to conduct planetary transfers or leave planets. \\(v_3\\) : Required to exit the Solar System and explore interstellar space.","title":"\ud83d\udef0\ufe0f Summary of Practical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#real-world-examples","text":"Mission Velocity Used Purpose ISS Launches (e.g., SpaceX) \\(v_1\\) Satellite orbiting Earth Mars Rovers (Perseverance) \\(v_2\\) Escape Earth to reach Mars Voyager 1/2 (NASA, 1977) \\(v_3\\) Escape the Solar System \ud83d\udca1 These concepts not only define theoretical thresholds but also directly inform mission planning, fuel budgeting, and spacecraft engineering .","title":"\ud83c\udf0d Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth \ud83d\udd0d Understanding the Physics Concepts \u2696\ufe0f Newton\u2019s Law of Universal Gravitation The gravitational force \\(F\\) between two masses is given by: \\[ F = G\\frac{m_1 m_2}{r^2} \\] where: - \\(G \\approx 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) is the gravitational constant - \\(m_1\\) and \\(m_2\\) are the masses - \\(r\\) is the distance between the centers of the two masses For a small object (payload) near Earth: \\[ F = G\\frac{M_{\\oplus} m}{r^2} \\] where \\(M_{\\oplus}\\) is Earth's mass, \\(m\\) is the payload mass, and \\(r\\) is the distance from Earth's center. \ud83c\udf0c Types of Trajectories-Visual The nature of the trajectory depends on the total mechanical energy \\(E\\) : \\[ E = \\frac{1}{2}mv^2 - \\frac{GM_{\\oplus}m}{r} \\] Elliptical Orbit : \\(E < 0\\) Parabolic Escape Trajectory : \\(E = 0\\) Hyperbolic Escape Trajectory : \\(E > 0\\) Velocity thresholds: - Orbital Velocity (for circular orbit): \\[ v_{\\text{orb}} = \\sqrt{\\frac{GM_{\\oplus}}{r}} \\] Escape Velocity : \\[ v_{\\text{esc}} = \\sqrt{2} \\cdot v_{\\text{orb}} = \\sqrt{\\frac{2GM_{\\oplus}}{r}} \\] \ud83e\ude90 Kepler's Laws (for Elliptical Orbits) First Law (Elliptical Orbits) : Planets move in ellipses with the Sun (or central mass) at one focus. Second Law (Equal Areas in Equal Times) : A line joining a planet and the Sun sweeps out equal areas in equal intervals of time. Third Law (Harmonic Law) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] \ud83e\uddee Defining the Problem Mathematically \ud83e\udded Variables and Initial Conditions Let the payload be released from a moving rocket at altitude \\(h\\) . Define: \\(r_0 = R_{\\oplus} + h\\) : Initial radial distance from Earth's center \\(\\vec{v}_0\\) : Initial velocity vector of the payload \\(\\theta\\) : Angle between velocity and local horizontal \\(m\\) : Mass of payload (may cancel out in equations) \\(\\vec{r}(t)\\) : Position vector as a function of time \\(\\vec{v}(t)\\) : Velocity vector as a function of time \ud83e\udded Equations of Motion under Gravity Let the acceleration be determined only by gravity (neglecting drag and other forces). The equation of motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is a second-order ordinary differential equation (ODE) Can be solved numerically using methods like Runge-Kutta \ud83e\uddfe Summary of Key Constants \\(G = 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) \\(M_{\\oplus} = 5.972 \\times 10^{24}~\\text{kg}\\) \\(R_{\\oplus} = 6.371 \\times 10^6~\\text{m}\\) \ud83e\uddee Chapter 3: Numerical Simulation of Payload Trajectory \ud83e\uddf0 Choose a Numerical Method To simulate the motion of a payload under Earth's gravity, we need to solve the second-order differential equation : \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is equivalent to solving a system of first-order ODEs by introducing velocity as a separate state: Let: \\(\\vec{r}(t)\\) : position vector \\(\\vec{v}(t) = \\frac{d\\vec{r}}{dt}\\) : velocity vector Then: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] \u2705 Method Selection Euler\u2019s Method : Simple but inaccurate for orbital simulations. Runge-Kutta 4th Order (RK4) : Offers a good balance of accuracy and efficiency . Chosen for this simulation. \u23f1\ufe0f Define Simulation Parameters We need to define: Initial position \\(\\vec{r}_0\\) (depends on altitude \\(h\\) ) Initial velocity \\(\\vec{v}_0\\) (depends on angle \\(\\theta\\) ) Gravitational constant \\(G\\) and Earth's mass \\(M_{\\oplus}\\) Time step \\(\\Delta t\\) Total simulation time \\(T\\) \ud83d\udc0d Implementing the Simulation in Python \ud83c\udfaf Objective: Simulate and visualize the trajectory of a payload released near Earth using RK4. \u2705 Inputs: Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Release angle \\(\\theta\\) Altitude \\(h\\) Time step \\(\\Delta t\\) \ud83d\udce6 Output: Time-evolving position vectors \\(\\vec{r}(t)\\) A 2D trajectory plot in space import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Earth mass (kg) R_earth = 6.371e6 # Earth radius (m) # Simulation setup altitude = 300e3 # Initial altitude (m) r0 = np.array([R_earth + altitude, 0]) # Initial position (m) angles = [0] # Straight launch velocities = [7300, 7500, 7700, 7900, 8100, 8300] # Different speeds (m/s) dt = 1.5 # Time step (s) T = 5500 # Total simulation time (s) steps = int(T / dt) # Define acceleration under gravity def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 integrator def rk4_orbit(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = acceleration(r[i]) k1r = v[i] k2v = acceleration(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = acceleration(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = acceleration(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: r = r[:i+2] # Stop at impact break return r # Plotting plt.figure(figsize=(9, 9)) colors = ['#0077b6', '#00b4d8', '#90e0ef', '#ffb703', '#fb8500', '#d00000'] for v_mag, color in zip(velocities, colors): angle = np.radians(20) # slight angle v0 = v_mag * np.array([np.cos(angle), np.sin(angle)]) trajectory = rk4_orbit(r0, v0) plt.plot(trajectory[:, 0] / 1e6, trajectory[:, 1] / 1e6, label=f'$v = {v_mag}$ m/s', linewidth=2.0, color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='#6fa8dc', zorder=0) plt.gca().add_artist(earth) # Style the plot plt.title(\"\ud83e\ude90 Stylized Payload Trajectories (Different Velocities)\", fontsize=16, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend(loc='upper right', fontsize=10) plt.tight_layout() plt.show() \ud83d\ude80 Visualizing and Analyzing Payload Trajectories This section presents the visual and analytical interpretation of simulated trajectories for payloads released near Earth under the influence of gravity. \ud83c\udfaf Objectives \ud83d\udcc8 Plot and analyze 2D trajectories of payloads. \ud83c\udf00 Classify orbits: elliptical , hyperbolic , and suborbital . \ud83d\udca1 Highlight critical velocities like orbital and escape velocity . \ud83e\udde0 Draw practical conclusions for space missions (e.g., reentry, orbital insertion). \ud83d\udcca Visualizing the Results \u2733\ufe0f Key Quantities Orbital velocity at low Earth orbit: $$ v_{orbital} = \\sqrt{\\frac{GM}{R + h}} $$ Escape velocity from the same altitude: $$ v_{escape} = \\sqrt{\\frac{2GM}{R + h}} $$ Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of Earth, - \\(R\\) = radius of Earth, - \\(h\\) = altitude of payload. \ud83d\udcd0 Trajectory Types Bound orbits : Elliptical paths where \\(E < 0\\) . Escape trajectories : Hyperbolic paths where \\(E > 0\\) . Reentry/Suborbital : Short arcs falling back to Earth. \ud83d\udd27 Plotting in Python (2D Example) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) dt = 1.5 T = 6000 steps = int(T / dt) # Function: Gravitational acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 Integrator def rk4(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = gravity(r[i]) k1r = v[i] k2v = gravity(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = gravity(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = gravity(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: return r[:i+2] return r # Simulation velocities = [7200, 7600, 8000, 8400, 11200] # m/s colors = ['blue', 'green', 'orange', 'crimson', 'purple'] labels = ['Suborbital', 'Low Orbit', 'Elliptical', 'High Elliptical', 'Escape'] plt.figure(figsize=(9, 9)) for v_mag, color, label in zip(velocities, colors, labels): v0 = v_mag * np.array([0, 1]) path = rk4(r0, v0) plt.plot(path[:, 0]/1e6, path[:, 1]/1e6, label=f'{label}: {v_mag} m/s', color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='skyblue', zorder=0) plt.gca().add_artist(earth) # Plot styling plt.title(\"\ud83d\udd2d Payload Trajectories from LEO\", fontsize=15, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend() plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#understanding-the-physics-concepts","text":"","title":"\ud83d\udd0d Understanding the Physics Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational force \\(F\\) between two masses is given by: \\[ F = G\\frac{m_1 m_2}{r^2} \\] where: - \\(G \\approx 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) is the gravitational constant - \\(m_1\\) and \\(m_2\\) are the masses - \\(r\\) is the distance between the centers of the two masses For a small object (payload) near Earth: \\[ F = G\\frac{M_{\\oplus} m}{r^2} \\] where \\(M_{\\oplus}\\) is Earth's mass, \\(m\\) is the payload mass, and \\(r\\) is the distance from Earth's center.","title":"\u2696\ufe0f Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories-visual","text":"The nature of the trajectory depends on the total mechanical energy \\(E\\) : \\[ E = \\frac{1}{2}mv^2 - \\frac{GM_{\\oplus}m}{r} \\] Elliptical Orbit : \\(E < 0\\) Parabolic Escape Trajectory : \\(E = 0\\) Hyperbolic Escape Trajectory : \\(E > 0\\) Velocity thresholds: - Orbital Velocity (for circular orbit): \\[ v_{\\text{orb}} = \\sqrt{\\frac{GM_{\\oplus}}{r}} \\] Escape Velocity : \\[ v_{\\text{esc}} = \\sqrt{2} \\cdot v_{\\text{orb}} = \\sqrt{\\frac{2GM_{\\oplus}}{r}} \\]","title":"\ud83c\udf0c Types of Trajectories-Visual"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-laws-for-elliptical-orbits","text":"First Law (Elliptical Orbits) : Planets move in ellipses with the Sun (or central mass) at one focus. Second Law (Equal Areas in Equal Times) : A line joining a planet and the Sun sweeps out equal areas in equal intervals of time. Third Law (Harmonic Law) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\]","title":"\ud83e\ude90 Kepler's Laws (for Elliptical Orbits)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#defining-the-problem-mathematically","text":"","title":"\ud83e\uddee Defining the Problem Mathematically"},{"location":"1%20Physics/2%20Gravity/Problem_3/#variables-and-initial-conditions","text":"Let the payload be released from a moving rocket at altitude \\(h\\) . Define: \\(r_0 = R_{\\oplus} + h\\) : Initial radial distance from Earth's center \\(\\vec{v}_0\\) : Initial velocity vector of the payload \\(\\theta\\) : Angle between velocity and local horizontal \\(m\\) : Mass of payload (may cancel out in equations) \\(\\vec{r}(t)\\) : Position vector as a function of time \\(\\vec{v}(t)\\) : Velocity vector as a function of time","title":"\ud83e\udded Variables and Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-under-gravity","text":"Let the acceleration be determined only by gravity (neglecting drag and other forces). The equation of motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is a second-order ordinary differential equation (ODE) Can be solved numerically using methods like Runge-Kutta","title":"\ud83e\udded Equations of Motion under Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-of-key-constants","text":"\\(G = 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) \\(M_{\\oplus} = 5.972 \\times 10^{24}~\\text{kg}\\) \\(R_{\\oplus} = 6.371 \\times 10^6~\\text{m}\\)","title":"\ud83e\uddfe Summary of Key Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#chapter-3-numerical-simulation-of-payload-trajectory","text":"","title":"\ud83e\uddee Chapter 3: Numerical Simulation of Payload Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#choose-a-numerical-method","text":"To simulate the motion of a payload under Earth's gravity, we need to solve the second-order differential equation : \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is equivalent to solving a system of first-order ODEs by introducing velocity as a separate state: Let: \\(\\vec{r}(t)\\) : position vector \\(\\vec{v}(t) = \\frac{d\\vec{r}}{dt}\\) : velocity vector Then: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\]","title":"\ud83e\uddf0 Choose a Numerical Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#method-selection","text":"Euler\u2019s Method : Simple but inaccurate for orbital simulations. Runge-Kutta 4th Order (RK4) : Offers a good balance of accuracy and efficiency . Chosen for this simulation.","title":"\u2705 Method Selection"},{"location":"1%20Physics/2%20Gravity/Problem_3/#define-simulation-parameters","text":"We need to define: Initial position \\(\\vec{r}_0\\) (depends on altitude \\(h\\) ) Initial velocity \\(\\vec{v}_0\\) (depends on angle \\(\\theta\\) ) Gravitational constant \\(G\\) and Earth's mass \\(M_{\\oplus}\\) Time step \\(\\Delta t\\) Total simulation time \\(T\\)","title":"\u23f1\ufe0f Define Simulation Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#implementing-the-simulation-in-python","text":"","title":"\ud83d\udc0d Implementing the Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Simulate and visualize the trajectory of a payload released near Earth using RK4.","title":"\ud83c\udfaf Objective:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#inputs","text":"Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Release angle \\(\\theta\\) Altitude \\(h\\) Time step \\(\\Delta t\\)","title":"\u2705 Inputs:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output","text":"Time-evolving position vectors \\(\\vec{r}(t)\\) A 2D trajectory plot in space import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Earth mass (kg) R_earth = 6.371e6 # Earth radius (m) # Simulation setup altitude = 300e3 # Initial altitude (m) r0 = np.array([R_earth + altitude, 0]) # Initial position (m) angles = [0] # Straight launch velocities = [7300, 7500, 7700, 7900, 8100, 8300] # Different speeds (m/s) dt = 1.5 # Time step (s) T = 5500 # Total simulation time (s) steps = int(T / dt) # Define acceleration under gravity def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 integrator def rk4_orbit(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = acceleration(r[i]) k1r = v[i] k2v = acceleration(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = acceleration(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = acceleration(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: r = r[:i+2] # Stop at impact break return r # Plotting plt.figure(figsize=(9, 9)) colors = ['#0077b6', '#00b4d8', '#90e0ef', '#ffb703', '#fb8500', '#d00000'] for v_mag, color in zip(velocities, colors): angle = np.radians(20) # slight angle v0 = v_mag * np.array([np.cos(angle), np.sin(angle)]) trajectory = rk4_orbit(r0, v0) plt.plot(trajectory[:, 0] / 1e6, trajectory[:, 1] / 1e6, label=f'$v = {v_mag}$ m/s', linewidth=2.0, color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='#6fa8dc', zorder=0) plt.gca().add_artist(earth) # Style the plot plt.title(\"\ud83e\ude90 Stylized Payload Trajectories (Different Velocities)\", fontsize=16, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend(loc='upper right', fontsize=10) plt.tight_layout() plt.show()","title":"\ud83d\udce6 Output:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualizing-and-analyzing-payload-trajectories","text":"This section presents the visual and analytical interpretation of simulated trajectories for payloads released near Earth under the influence of gravity.","title":"\ud83d\ude80 Visualizing and Analyzing Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objectives","text":"\ud83d\udcc8 Plot and analyze 2D trajectories of payloads. \ud83c\udf00 Classify orbits: elliptical , hyperbolic , and suborbital . \ud83d\udca1 Highlight critical velocities like orbital and escape velocity . \ud83e\udde0 Draw practical conclusions for space missions (e.g., reentry, orbital insertion).","title":"\ud83c\udfaf Objectives"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualizing-the-results","text":"","title":"\ud83d\udcca Visualizing the Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-quantities","text":"Orbital velocity at low Earth orbit: $$ v_{orbital} = \\sqrt{\\frac{GM}{R + h}} $$ Escape velocity from the same altitude: $$ v_{escape} = \\sqrt{\\frac{2GM}{R + h}} $$ Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of Earth, - \\(R\\) = radius of Earth, - \\(h\\) = altitude of payload.","title":"\u2733\ufe0f Key Quantities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types","text":"Bound orbits : Elliptical paths where \\(E < 0\\) . Escape trajectories : Hyperbolic paths where \\(E > 0\\) . Reentry/Suborbital : Short arcs falling back to Earth.","title":"\ud83d\udcd0 Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-in-python-2d-example","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) dt = 1.5 T = 6000 steps = int(T / dt) # Function: Gravitational acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 Integrator def rk4(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = gravity(r[i]) k1r = v[i] k2v = gravity(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = gravity(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = gravity(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: return r[:i+2] return r # Simulation velocities = [7200, 7600, 8000, 8400, 11200] # m/s colors = ['blue', 'green', 'orange', 'crimson', 'purple'] labels = ['Suborbital', 'Low Orbit', 'Elliptical', 'High Elliptical', 'Escape'] plt.figure(figsize=(9, 9)) for v_mag, color, label in zip(velocities, colors, labels): v0 = v_mag * np.array([0, 1]) path = rk4(r0, v0) plt.plot(path[:, 0]/1e6, path[:, 1]/1e6, label=f'{label}: {v_mag} m/s', color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='skyblue', zorder=0) plt.gca().add_artist(earth) # Plot styling plt.title(\"\ud83d\udd2d Payload Trajectories from LEO\", fontsize=15, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udd27 Plotting in Python (2D Example)"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}