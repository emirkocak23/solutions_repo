{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # \ud83d\udcd8 Theoretical Foundation \ud83e\uddee Derivation of Projectile Motion from Newton's Laws We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis) \u2733\ufe0f Assumptions: No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\) \ud83d\ude80 1. Equations of Motion Horizontal motion (constant velocity): - Acceleration: \\(a_x = 0\\) - Velocity: \\(v_x = v_0\\cos(\\theta)\\) - Displacement: $$ x(t) = v_0\\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): - Acceleration: \\(a_y = -g\\) - Velocity: \\(v_y = v_0\\sin(\\theta) - gt\\) - Displacement: $$ y(t) = v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ \ud83d\udccf 2. Time of Flight The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\] \u2194\ufe0f 3. Horizontal Range \\(R\\) Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\) \ud83e\uddea 4. Effect of Initial Conditions on Range Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation) \u2705 These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis. \ud83d\udcca Analysis of the Range \ud83d\udd0d 1. Mathematical Relationship Between Range and Angle Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity \ud83d\udd39 Key Observations: Range depends non-linearly on \\(\\theta\\) through \\(\\sin(2\\theta)\\) . The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta=90^\\circ\\) . Therefore, the maximum range occurs at : $$ \\boxed{\\theta=45^\\circ} $$ \u2699\ufe0f 2. Effect of Initial Velocity ( \\(v_0\\) ) From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak. \ud83c\udf0d 3. Effect of Gravitational Acceleration ( \\(g\\) ) Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range . \ud83e\uddd7 4. Launch Height (Advanced) When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] \u26a0\ufe0f Note: Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height. \u2705 Summary Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions. \ud83c\udf10 Practical Applications of Projectile Motion \ud83c\udfaf 1. Real-World Situations Involving Projectile Motion Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields. \ud83c\udf04 2. Effects of Terrain, Drag, and Wind \ud83c\udfde\ufe0f a. Uneven Terrain When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation. \ud83c\udf2c\ufe0f b. Air Resistance (Drag) Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: $$ m\\frac{dv_x}{dt}=-kv_x $$ In vertical direction: $$ m\\frac{dv_y}{dt}=-mg-kv_y $$ These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta. \ud83c\udf2a\ufe0f c. Wind Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\] \ud83e\udde0 3. Adapting the Model To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data. \u2705 Summary Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis. \ud83d\ude80 Implementation: Computational Simulation of Projectile Motion This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions. \ud83d\udccc Objective Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\) \ud83d\udc0d Python Code (Jupyter Notebook Compatible) import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height) Gravity constant, g = 9.81 Function to compute trajectory, def trajectory(v0, angle_deg, num_points=300): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num_points) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y Define scenarios, cases_a = [(30, 45, '#e74c3c'), (40, 45, '#9b59b6'), (50, 45, '#27ae60')] # red, purple, green cases_b = [(50, 15, '#e74c3c'), (50, 45, '#9b59b6'), (50, 75, '#27ae60')] # same speed, different angles Plotting, fig, axs = plt.subplots(2, 1, figsize=(12, 10)) titles = ['(a) Different Speeds at 45\u00b0', '(b) Same Speed, Different Angles'] Prettier font, plt.rcParams.update({'font.size': 12, 'font.family': 'DejaVu Sans'}) Plot (a), for v0, angle, color in cases_a: x, y = trajectory(v0, angle) axs[0].plot(x, y, color=color, linewidth=2, label=f'{v0} m/s') axs[0].set_title(titles[0], fontsize=14, weight='bold') axs[0].set_xlabel('Range (m)') axs[0].set_ylabel('Height (m)') axs[0].legend(title='Initial Speed', loc='upper right') axs[0].grid(True, linestyle='--', alpha=0.6) Plot (b), for v0, angle, color in cases_b: x, y = trajectory(v0, angle) axs[1].plot(x, y, color=color, linewidth=2, label=f'{angle}\u00b0') axs[1].set_title(titles[1], fontsize=14, weight='bold') axs[1].set_xlabel('Range (m)') axs[1].set_ylabel('Height (m)') axs[1].legend(title='Launch Angle', loc='upper right') axs[1].grid(True, linestyle='--', alpha=0.6) Tight layout for spacing, plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"# \ud83d\udcd8 Theoretical Foundation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-projectile-motion-from-newtons-laws","text":"We begin by considering a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The motion can be decomposed into two perpendicular components: Horizontal (x-axis) Vertical (y-axis)","title":"\ud83e\uddee Derivation of Projectile Motion from Newton's Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#assumptions","text":"No air resistance Constant gravitational acceleration \\(g\\) Launched from the origin at time \\(t = 0\\)","title":"\u2733\ufe0f Assumptions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-equations-of-motion","text":"Horizontal motion (constant velocity): - Acceleration: \\(a_x = 0\\) - Velocity: \\(v_x = v_0\\cos(\\theta)\\) - Displacement: $$ x(t) = v_0\\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): - Acceleration: \\(a_y = -g\\) - Velocity: \\(v_y = v_0\\sin(\\theta) - gt\\) - Displacement: $$ y(t) = v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$","title":"\ud83d\ude80 1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight","text":"The projectile hits the ground when \\(y(t) = 0\\) . Solving: \\[ v_0\\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 = 0 \\] \\[ t(v_0\\sin(\\theta) - \\frac{1}{2}gt) = 0 \\] Non-zero solution: \\[ t = \\frac{2v_0\\sin(\\theta)}{g} \\]","title":"\ud83d\udccf 2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-horizontal-range-r","text":"Substitute the total time of flight into the horizontal displacement: \\[ R = x(t) = v_0\\cos(\\theta) \\cdot \\frac{2v_0\\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2\\sin(2\\theta)}{g}} \\] This shows that range is maximum when \\(\\sin(2\\theta) = 1\\) , i.e. \\(\\theta = 45^\\circ\\)","title":"\u2194\ufe0f 3. Horizontal Range \\(R\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-effect-of-initial-conditions-on-range","text":"Initial Velocity \\(v_0\\) : Range is proportional to \\(v_0^2\\) Doubling speed increases range fourfold Angle \\(\\theta\\) : Affects both vertical and horizontal components Maximum range at \\(\\theta = 45^\\circ\\) (in symmetric conditions) Gravitational Acceleration \\(g\\) : Inverse relation: higher gravity \u2192 shorter range Launch Height (not included above) : Adds vertical displacement Increases total time in air \u2192 longer range (needs new derivation)","title":"\ud83e\uddea 4. Effect of Initial Conditions on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#these-equations-form-the-idealized-model-of-projectile-motion-laying-the-foundation-for-further-numerical-or-simulation-based-analysis","text":"","title":"\u2705 These equations form the idealized model of projectile motion, laying the foundation for further numerical or simulation-based analysis."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"\ud83d\udcca Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-mathematical-relationship-between-range-and-angle","text":"Using the derived formula from earlier: \\[ R=\\frac{v_0^2\\sin(2\\theta)}{g} \\] Where: - \\(R\\) is the horizontal range - \\(v_0\\) is the initial velocity - \\(\\theta\\) is the launch angle - \\(g\\) is the acceleration due to gravity","title":"\ud83d\udd0d 1. Mathematical Relationship Between Range and Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Range depends non-linearly on \\(\\theta\\) through \\(\\sin(2\\theta)\\) . The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta=90^\\circ\\) . Therefore, the maximum range occurs at : $$ \\boxed{\\theta=45^\\circ} $$","title":"\ud83d\udd39 Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effect-of-initial-velocity-v_0","text":"From the formula: \\[ R\\propto v_0^2 \\] Doubling \\(v_0\\) quadruples the range. Plotting range vs. angle for different velocities shifts the amplitude of the curve but not the position of the peak.","title":"\u2699\ufe0f 2. Effect of Initial Velocity (\\(v_0\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration-g","text":"Range is inversely proportional to \\(g\\) : \\[ R\\propto\\frac{1}{g} \\] Lower gravity (e.g., on the Moon) results in a longer range . Higher gravity (e.g., on Jupiter) produces a shorter range .","title":"\ud83c\udf0d 3. Effect of Gravitational Acceleration (\\(g\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-launch-height-advanced","text":"When the projectile is launched from a height \\(h>0\\) , total time of flight increases. The vertical displacement becomes: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h \\] To find time of flight \\(t_f\\) , solve: \\[ 0=h+v_0\\sin(\\theta)t_f-\\frac{1}{2}gt_f^2 \\] This is a quadratic in \\(t_f\\) : \\[ \\frac{1}{2}gt_f^2-v_0\\sin(\\theta)t_f-h=0 \\] Solve for \\(t_f\\) using the quadratic formula: \\[ t_f=\\frac{v_0\\sin(\\theta)+\\sqrt{(v_0\\sin(\\theta))^2+2gh}}{g} \\] Then calculate range: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\]","title":"\ud83e\uddd7 4. Launch Height (Advanced)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#note","text":"Range increases with height. The angle for maximum range no longer remains 45\u00b0 when launching from a height.","title":"\u26a0\ufe0f Note:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Parameter Effect on Range Initial Velocity \\(v_0\\) Quadratic increase ( \\(\\propto v_0^2\\) ) Launch Angle \\(\\theta\\) Max at \\(45^\\circ\\) (flat launch) Gravity \\(g\\) Inversely proportional Launch Height \\(h\\) Increases range, changes optimal angle","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#this-analysis-provides-a-full-picture-of-how-the-range-responds-to-varying-parameters-in-ideal-and-slightly-more-realistic-conditions","text":"","title":"This analysis provides a full picture of how the range responds to varying parameters in ideal and slightly more realistic conditions."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"\ud83c\udf10 Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-situations-involving-projectile-motion","text":"Projectile motion is observed in various natural and engineered systems: Sports: A soccer ball, basketball, or javelin follows a projectile path after being launched. The initial velocity and launch angle determine whether the ball reaches the goal or basket. Engineering: Water fountains or fire hoses arc based on launch parameters. Ballistics in defense and aerospace engineering heavily depend on accurate projectile modeling. Astrophysics: Space missions use orbital mechanics \u2014 an extension of projectile motion under gravity. Launching a probe involves solving similar equations in non-Earth gravity fields.","title":"\ud83c\udfaf 1. Real-World Situations Involving Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-effects-of-terrain-drag-and-wind","text":"","title":"\ud83c\udf04 2. Effects of Terrain, Drag, and Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-uneven-terrain","text":"When projectiles land on non-flat surfaces , the simple range formula no longer applies. Suppose the landing height is different from the launch height \\(h_0\\) , then total time of flight \\(t_f\\) must be found by solving: \\[ y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2+h_0 \\] Final range becomes: \\[ R=v_0\\cos(\\theta)\\cdot t_f \\] Requires solving a quadratic equation for \\(t_f\\) and using it in range computation.","title":"\ud83c\udfde\ufe0f a. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-air-resistance-drag","text":"Real trajectories are affected by drag force proportional to velocity: \\[ F_d=-kv \\] Where: - \\(F_d\\) is the drag force, - \\(k\\) is a constant depending on air density and shape, - \\(v\\) is velocity. This leads to nonlinear differential equations : In horizontal direction: $$ m\\frac{dv_x}{dt}=-kv_x $$ In vertical direction: $$ m\\frac{dv_y}{dt}=-mg-kv_y $$ These must be solved numerically using techniques like Euler\u2019s method or Runge-Kutta.","title":"\ud83c\udf2c\ufe0f b. Air Resistance (Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#c-wind","text":"Wind introduces additional velocity components: - Tailwind increases range. - Headwind decreases range. - Crosswind changes the direction of the projectile, affecting accuracy. Effective horizontal velocity becomes: \\[ v_{\\text{effective}}=v_0\\cos(\\theta)\\pm v_{\\text{wind}} \\]","title":"\ud83c\udf2a\ufe0f c. Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-adapting-the-model","text":"To make the model more realistic: Include drag : Use numerical simulation (e.g., Runge-Kutta) to solve motion with air resistance. Include wind : Modify initial velocity vector to account for wind speed and direction. Simulate terrain : Adjust impact height based on known terrain elevation data.","title":"\ud83e\udde0 3. Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary_1","text":"Realistic Factor Effect on Range Modeling Approach Uneven Terrain Alters time of flight Quadratic equation with height offset Air Resistance Shortens range significantly Numerical solution of ODEs Wind Alters path and accuracy Adjust velocity components By expanding our model, we bridge the gap between ideal physics and real-world scenarios, increasing the accuracy and relevance of projectile analysis.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-computational-simulation-of-projectile-motion","text":"This section provides a Python implementation to simulate projectile motion, analyze the range as a function of angle, and visualize the effects of varying initial conditions.","title":"\ud83d\ude80 Implementation: Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#objective","text":"Simulate projectile motion under ideal conditions. Plot Range vs. Angle of Projection . Allow the user to vary: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Initial height \\(h_0\\)","title":"\ud83d\udccc Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-jupyter-notebook-compatible","text":"","title":"\ud83d\udc0d Python Code (Jupyter Notebook Compatible)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt # --- Function to calculate range --- def calculate_range(v0, angle_deg, g=9.81, h0=0): angle_rad = np.radians(angle_deg) v0x = v0 * np.cos(angle_rad) v0y = v0 * np.sin(angle_rad) if h0 == 0: # Flat terrain (simplified range formula) R = (v0**2 * np.sin(2 * angle_rad)) / g else: # Non-zero launch height, solve for time of flight and range t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g R = v0x * t_flight return R # --- Function to simulate and plot --- def plot_range_vs_angle(v0, g=9.81, h0=0): angles = np.linspace(0, 90, 500) ranges = [calculate_range(v0, angle, g, h0) for angle in angles] plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f'v\u2080={v0} m/s, g={g} m/s\u00b2, h\u2080={h0} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.show() # --- Example usage --- # Modify these parameters to explore different conditions initial_velocity = 30 # m/s gravity = 9.81 # m/s\u00b2 initial_height = 0 # m plot_range_vs_angle(initial_velocity, gravity, initial_height) Gravity constant, g = 9.81 Function to compute trajectory, def trajectory(v0, angle_deg, num_points=300): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num_points) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y Define scenarios, cases_a = [(30, 45, '#e74c3c'), (40, 45, '#9b59b6'), (50, 45, '#27ae60')] # red, purple, green cases_b = [(50, 15, '#e74c3c'), (50, 45, '#9b59b6'), (50, 75, '#27ae60')] # same speed, different angles Plotting, fig, axs = plt.subplots(2, 1, figsize=(12, 10)) titles = ['(a) Different Speeds at 45\u00b0', '(b) Same Speed, Different Angles'] Prettier font, plt.rcParams.update({'font.size': 12, 'font.family': 'DejaVu Sans'}) Plot (a), for v0, angle, color in cases_a: x, y = trajectory(v0, angle) axs[0].plot(x, y, color=color, linewidth=2, label=f'{v0} m/s') axs[0].set_title(titles[0], fontsize=14, weight='bold') axs[0].set_xlabel('Range (m)') axs[0].set_ylabel('Height (m)') axs[0].legend(title='Initial Speed', loc='upper right') axs[0].grid(True, linestyle='--', alpha=0.6) Plot (b), for v0, angle, color in cases_b: x, y = trajectory(v0, angle) axs[1].plot(x, y, color=color, linewidth=2, label=f'{angle}\u00b0') axs[1].set_title(titles[1], fontsize=14, weight='bold') axs[1].set_xlabel('Range (m)') axs[1].set_ylabel('Height (m)') axs[1].legend(title='Launch Angle', loc='upper right') axs[1].grid(True, linestyle='--', alpha=0.6) Tight layout for spacing, plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \u2705 Task Breakdown: Investigating the Dynamics of a Forced Damped Pendulum I. Theoretical Foundation \ud83d\udccc Governing Equation The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(b\\) : Damping coefficient - \\(g\\) : Gravitational acceleration - \\(L\\) : Length of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Frequency of the external driving force \ud83d\udccc Small-Angle Approximation For small oscillations where \\(|\\theta| \\ll 1\\) , we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order nonhomogeneous differential equation and can be analyzed more easily than the original nonlinear equation. \ud83d\udccc Approximate Analytical Solution The general solution consists of: - A homogeneous solution (transient part) depending on initial conditions and damping - A particular solution (steady-state) driven by \\(A\\cos(\\omega t)\\) Assuming a solution of the form: \\[ \\theta(t) = \\Theta \\cos(\\omega t - \\delta) \\] Then, under steady-state conditions, we find: \\[ \\Theta = \\frac{A}{\\sqrt{(g/L - \\omega^2)^2 + (b\\omega)^2}} \\] Where: - \\(\\Theta\\) : Steady-state amplitude - \\(\\delta\\) : Phase lag between driving force and response \ud83d\udccc Resonance Condition Resonance occurs when the denominator is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At this frequency: - The amplitude \\(\\Theta\\) is maximized - Energy input from the driving force matches the natural oscillation frequency - Physical systems can experience large oscillations (resonance phenomenon) II. Analysis of Dynamics \ud83d\udccc Parameter Dependencies Study how varying the following parameters affects the system: Damping coefficient \\(b\\) : Higher \\(b\\) : Faster decay of oscillations, suppresses chaos Lower \\(b\\) : Allows more complex behavior (e.g., quasiperiodicity, chaos) Driving amplitude \\(A\\) : Small \\(A\\) : Linear, predictable motion Large \\(A\\) : Can induce chaotic behavior Driving frequency \\(\\omega\\) : Near resonance: Maximum energy transfer Away from resonance: Damped response \ud83d\udccc Characterizing Motion Regimes Depending on parameters, the pendulum may exhibit: Periodic motion : Oscillations repeat after a fixed time Seen when damping and driving are moderate Quasiperiodic motion : Oscillations never exactly repeat but show structured patterns Multiple incommensurate frequencies involved Chaotic motion : Sensitive dependence on initial conditions Aperiodic and seemingly random Detected using tools like Poincar\u00e9 sections and Lyapunov exponents \ud83d\udccc Physical Interpretations Periodic : Predictable; useful in clocks and timing systems Quasiperiodic : Found in some biological rhythms and coupled oscillators Chaotic : Reflects unpredictability in systems like weather patterns or turbulent flows III. \ud83d\udee0\ufe0f Practical Applications The forced damped pendulum models a variety of real-world systems that involve periodic driving and energy dissipation. Below are some key applications: \ud83d\udd0b 1. Energy Harvesting Devices Piezoelectric or electromagnetic harvesters often model their mechanical components as damped oscillators with forcing. Vibrations in the environment serve as the driving force. Optimal energy harvesting occurs near resonance , where the amplitude of motion is maximized. The governing dynamics resemble: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) $$ Tuning the system to resonate at ambient vibration frequencies enhances energy output. \ud83c\udf09 2. Suspension Bridges and Structural Dynamics Components of bridges or tall buildings behave like forced oscillators under periodic loads (e.g., wind, traffic). The infamous Tacoma Narrows Bridge collapse was due to large-amplitude oscillations caused by wind-driven resonance. Proper damping ( \\(b\\) ) and tuning of natural frequency ( \\(\\sqrt{g/L}\\) ) are crucial in design. \u26a1 3. Driven RLC Circuits Electrical analog of the pendulum: $$ L\\frac{d^2q}{dt^2} + R\\frac{dq}{dt} + \\frac{q}{C} = V_0 \\cos(\\omega t) $$ This is mathematically identical to the forced damped pendulum equation. \\(L\\) , \\(R\\) , and \\(C\\) correspond to inertia , damping , and restoring force , respectively. Used to study resonance , filtering , and signal amplification in electronics. IV. \ud83e\uddee Computational Implementation To study the forced damped pendulum beyond analytical approximations, we implement a numerical simulation using Python. \ud83d\udccc 1. Differential Equation We rewrite the second-order ODE as a system of first-order equations: Let: \\(\\theta = x_1\\) \\(\\dot{\\theta} = x_2\\) Then: \\[ \\begin{cases} \\frac{dx_1}{dt} = x_2 \\\\ \\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t) \\end{cases} \\] \ud83d\udcbb 2. Python Implementation (V\u0131sual) import numpy as np import matplotlib.pyplot as plt # :straight_ruler: Time parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 omega_0 = np.sqrt(g / L) # :orange_heart: New pastel color palette pastel_colors = ['#a2d2ff', '#ffafcc', '#caffbf', '#ffd6a5', '#bdb2ff'] # :repeat: Runge-Kutta 4th Order Method def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # :art: Enhanced Plot Function def plot_pendulum(t, Y, title, color, linestyle='-', marker=None): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(14, 5), facecolor=\"#f7f7f7\") fig.suptitle(title, fontsize=17, fontweight='bold', color=color) # Time series axs[0].plot(t, theta, color=color, linestyle=linestyle, linewidth=2) axs[0].set_title(\"Angular Position Over Time\", fontsize=13) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(r\"$\\theta(t)$ (rad)\") axs[0].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) # Phase portrait axs[1].plot(theta, theta_dot, color=color, linestyle=linestyle, linewidth=1.8) axs[1].set_title(\"Phase Portrait\", fontsize=13) axs[1].set_xlabel(r\"$\\theta$ (rad)\") axs[1].set_ylabel(r\"$\\dot{\\theta}$ (rad/s)\") axs[1].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) plt.tight_layout() plt.show() # :dart: Initial conditions Y0 = np.array([0.3, 0.0]) # :one: Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_pendulum(t, Y, \"1) Simple Pendulum :crescent_moon:\", pastel_colors[0], linestyle='-.') # :two: Damped Pendulum gamma = 0.4 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_pendulum(t, Y, \"2) Damped Pendulum :droplet:\", pastel_colors[1], linestyle='--') # :three: Forced (no damping) A = 1.0 omega = 0.8 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_pendulum(t, Y, \"3) Forced Pendulum :zap:\", pastel_colors[2], linestyle='-') # :four: Forced + Damped gamma = 0.2 def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_pendulum(t, Y, \"4) Forced Damped Pendulum :cyclone:\", pastel_colors[3], linestyle='dashdot') # :five: Chaotic / Resonant Case A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_pendulum(t, Y, \"5) Chaotic Pendulum :fire:\", pastel_colors[4], linestyle='solid') \u2705 Bifurcation Diagram (Optional Advanced) To construct a bifurcation diagram: Vary \\(A\\) or \\(\\omega\\) over a range Plot sampled values of \\(\\theta\\) after transients decay Requires looping over parameters and saving final cycle values \ud83d\udc49 This can be added later for a deeper nonlinear analysis. \u2705 With these tools, you can fully explore the transition to chaos , resonance peaks, and sensitive dependence on parameters and initial conditions. Let me know if you'd like the bifurcation loop or enhancements like interactive sliders!","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-breakdown-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\u2705 Task Breakdown: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#i-theoretical-foundation","text":"","title":"I. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(b\\) : Damping coefficient - \\(g\\) : Gravitational acceleration - \\(L\\) : Length of the pendulum - \\(A\\) : Amplitude of the external driving force - \\(\\omega\\) : Frequency of the external driving force","title":"\ud83d\udccc Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations where \\(|\\theta| \\ll 1\\) , we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order nonhomogeneous differential equation and can be analyzed more easily than the original nonlinear equation.","title":"\ud83d\udccc Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-analytical-solution","text":"The general solution consists of: - A homogeneous solution (transient part) depending on initial conditions and damping - A particular solution (steady-state) driven by \\(A\\cos(\\omega t)\\) Assuming a solution of the form: \\[ \\theta(t) = \\Theta \\cos(\\omega t - \\delta) \\] Then, under steady-state conditions, we find: \\[ \\Theta = \\frac{A}{\\sqrt{(g/L - \\omega^2)^2 + (b\\omega)^2}} \\] Where: - \\(\\Theta\\) : Steady-state amplitude - \\(\\delta\\) : Phase lag between driving force and response","title":"\ud83d\udccc Approximate Analytical Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the denominator is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At this frequency: - The amplitude \\(\\Theta\\) is maximized - Energy input from the driving force matches the natural oscillation frequency - Physical systems can experience large oscillations (resonance phenomenon)","title":"\ud83d\udccc Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#ii-analysis-of-dynamics","text":"","title":"II. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-dependencies","text":"Study how varying the following parameters affects the system: Damping coefficient \\(b\\) : Higher \\(b\\) : Faster decay of oscillations, suppresses chaos Lower \\(b\\) : Allows more complex behavior (e.g., quasiperiodicity, chaos) Driving amplitude \\(A\\) : Small \\(A\\) : Linear, predictable motion Large \\(A\\) : Can induce chaotic behavior Driving frequency \\(\\omega\\) : Near resonance: Maximum energy transfer Away from resonance: Damped response","title":"\ud83d\udccc Parameter Dependencies"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#characterizing-motion-regimes","text":"Depending on parameters, the pendulum may exhibit: Periodic motion : Oscillations repeat after a fixed time Seen when damping and driving are moderate Quasiperiodic motion : Oscillations never exactly repeat but show structured patterns Multiple incommensurate frequencies involved Chaotic motion : Sensitive dependence on initial conditions Aperiodic and seemingly random Detected using tools like Poincar\u00e9 sections and Lyapunov exponents","title":"\ud83d\udccc Characterizing Motion Regimes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretations","text":"Periodic : Predictable; useful in clocks and timing systems Quasiperiodic : Found in some biological rhythms and coupled oscillators Chaotic : Reflects unpredictability in systems like weather patterns or turbulent flows","title":"\ud83d\udccc Physical Interpretations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#iii-practical-applications","text":"The forced damped pendulum models a variety of real-world systems that involve periodic driving and energy dissipation. Below are some key applications:","title":"III. \ud83d\udee0\ufe0f Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Piezoelectric or electromagnetic harvesters often model their mechanical components as damped oscillators with forcing. Vibrations in the environment serve as the driving force. Optimal energy harvesting occurs near resonance , where the amplitude of motion is maximized. The governing dynamics resemble: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) $$ Tuning the system to resonate at ambient vibration frequencies enhances energy output.","title":"\ud83d\udd0b 1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-and-structural-dynamics","text":"Components of bridges or tall buildings behave like forced oscillators under periodic loads (e.g., wind, traffic). The infamous Tacoma Narrows Bridge collapse was due to large-amplitude oscillations caused by wind-driven resonance. Proper damping ( \\(b\\) ) and tuning of natural frequency ( \\(\\sqrt{g/L}\\) ) are crucial in design.","title":"\ud83c\udf09 2. Suspension Bridges and Structural Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-driven-rlc-circuits","text":"Electrical analog of the pendulum: $$ L\\frac{d^2q}{dt^2} + R\\frac{dq}{dt} + \\frac{q}{C} = V_0 \\cos(\\omega t) $$ This is mathematically identical to the forced damped pendulum equation. \\(L\\) , \\(R\\) , and \\(C\\) correspond to inertia , damping , and restoring force , respectively. Used to study resonance , filtering , and signal amplification in electronics.","title":"\u26a1 3. Driven RLC Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#iv-computational-implementation","text":"To study the forced damped pendulum beyond analytical approximations, we implement a numerical simulation using Python.","title":"IV. \ud83e\uddee Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-differential-equation","text":"We rewrite the second-order ODE as a system of first-order equations: Let: \\(\\theta = x_1\\) \\(\\dot{\\theta} = x_2\\) Then: \\[ \\begin{cases} \\frac{dx_1}{dt} = x_2 \\\\ \\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t) \\end{cases} \\]","title":"\ud83d\udccc 1. Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-implementation-vsual","text":"import numpy as np import matplotlib.pyplot as plt # :straight_ruler: Time parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 omega_0 = np.sqrt(g / L) # :orange_heart: New pastel color palette pastel_colors = ['#a2d2ff', '#ffafcc', '#caffbf', '#ffd6a5', '#bdb2ff'] # :repeat: Runge-Kutta 4th Order Method def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # :art: Enhanced Plot Function def plot_pendulum(t, Y, title, color, linestyle='-', marker=None): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(14, 5), facecolor=\"#f7f7f7\") fig.suptitle(title, fontsize=17, fontweight='bold', color=color) # Time series axs[0].plot(t, theta, color=color, linestyle=linestyle, linewidth=2) axs[0].set_title(\"Angular Position Over Time\", fontsize=13) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(r\"$\\theta(t)$ (rad)\") axs[0].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) # Phase portrait axs[1].plot(theta, theta_dot, color=color, linestyle=linestyle, linewidth=1.8) axs[1].set_title(\"Phase Portrait\", fontsize=13) axs[1].set_xlabel(r\"$\\theta$ (rad)\") axs[1].set_ylabel(r\"$\\dot{\\theta}$ (rad/s)\") axs[1].grid(True, color='#e0e0e0', linestyle=':', linewidth=0.8) plt.tight_layout() plt.show() # :dart: Initial conditions Y0 = np.array([0.3, 0.0]) # :one: Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_pendulum(t, Y, \"1) Simple Pendulum :crescent_moon:\", pastel_colors[0], linestyle='-.') # :two: Damped Pendulum gamma = 0.4 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_pendulum(t, Y, \"2) Damped Pendulum :droplet:\", pastel_colors[1], linestyle='--') # :three: Forced (no damping) A = 1.0 omega = 0.8 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_pendulum(t, Y, \"3) Forced Pendulum :zap:\", pastel_colors[2], linestyle='-') # :four: Forced + Damped gamma = 0.2 def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_pendulum(t, Y, \"4) Forced Damped Pendulum :cyclone:\", pastel_colors[3], linestyle='dashdot') # :five: Chaotic / Resonant Case A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_pendulum(t, Y, \"5) Chaotic Pendulum :fire:\", pastel_colors[4], linestyle='solid')","title":"\ud83d\udcbb 2. Python Implementation (V\u0131sual)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram-optional-advanced","text":"To construct a bifurcation diagram: Vary \\(A\\) or \\(\\omega\\) over a range Plot sampled values of \\(\\theta\\) after transients decay Requires looping over parameters and saving final cycle values \ud83d\udc49 This can be added later for a deeper nonlinear analysis. \u2705 With these tools, you can fully explore the transition to chaos , resonance peaks, and sensitive dependence on parameters and initial conditions. Let me know if you'd like the bifurcation loop or enhancements like interactive sliders!","title":"\u2705 Bifurcation Diagram (Optional Advanced)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius \ud83e\udde0 Derivation of Kepler's Third Law for Circular Orbits Kepler's Third Law states: The square of the orbital period ( \\(T\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits , the derivation proceeds from Newton\u2019s Law of Gravitation and centripetal force : 1. Equating Gravitational and Centripetal Forces Gravitational force: \\[ F_g = \\frac{GMm}{r^2} \\] Centripetal force: \\[ F_c = \\frac{mv^2}{r} \\] Equating both: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Mass \\(m\\) cancels: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] Solve for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] 2. Orbital Period from Velocity The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] \u2705 Final Result (Kepler\u2019s Third Law): \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\Rightarrow T^2 \\propto r^3 \\] \ud83c\udf0c Significance of the \\(T^2 \\propto r^3\\) Relationship Helps determine distances of planets from stars. Enables estimation of masses of celestial bodies. Crucial in calculating satellite orbits , spacecraft trajectories . Valid for any object orbiting under gravity in a central field. \ud83c\udf0d Real-World Applications Examples where Kepler's Law applies: Moon around Earth \\(r = 3.84 \\times 10^8\\) m, \\(T = 27.3\\) days Planets in Solar System Approximate relation holds: \\(T^2 \\propto r^3\\) \\(T\\) in Earth years, \\(r\\) in AU \ud83e\uddea Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) \u2014 from 0.3 AU to 30 AU radii = np.linspace(0.3, 30, 300) * 1.496e11 # Calculate orbital periods using Kepler's Third Law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Prepare figure plt.figure(figsize=(10, 6)) colors = plt.cm.plasma(np.linspace(0, 1, len(radii))) # Gradient color map # Plot with colorful dots plt.scatter(radii**3, T**2, c=colors, s=10, edgecolor='black', linewidth=0.2, alpha=0.8, label=r'$\\mathbf{T^2 \\propto r^3}$') # Real Solar System planets (approximate data) planet_data = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86), 'Saturn': (9.58, 29.46), 'Uranus': (19.22, 84.01), 'Neptune': (30.05, 164.8) } # Plot planet points for planet, (r_au, T_years) in planet_data.items(): r3 = (r_au * 1.496e11) ** 3 T2 = (T_years * 365.25 * 24 * 3600) ** 2 plt.scatter(r3, T2, color='black', s=40, marker='o', label=planet) plt.annotate(planet, (r3, T2), textcoords=\"offset points\", xytext=(5, 5), fontsize=8) # Axis labels plt.xlabel(r'$r^3 \\, (m^3)$', fontsize=12) plt.ylabel(r'$T^2 \\, (s^2)$', fontsize=12) plt.title('\ud83c\udf0d Kepler\\'s Third Law with Planetary Orbits', fontsize=14) plt.grid(True, linestyle='--', alpha=0.5) # Custom legend handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) # Remove duplicates plt.legend(by_label.values(), by_label.keys(), fontsize=8, loc='upper left') plt.tight_layout() plt.show() \ud83d\udcd8 Problem 2: Escape Velocities and Cosmic Velocities \ud83e\udde0 Defining the First, Second, and Third Cosmic Velocities The cosmic velocities are the speeds needed to escape or orbit a celestial body. There are three important cosmic velocities: First Cosmic Velocity : The velocity needed to orbit a celestial body in a circular orbit at the surface level. This is also called the orbital velocity . Formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., Earth, Mars, etc.), - \\(r\\) is the radius of the celestial body. Second Cosmic Velocity : The velocity needed to escape the gravitational pull of a celestial body. This is also known as the escape velocity . Formula: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(r\\) is the distance from the center of the celestial body, - \\(M\\) is the mass of the celestial body, - \\(G\\) is the gravitational constant. Third Cosmic Velocity : The velocity required to escape the gravitational influence of the entire solar system or any star system. This velocity is needed to break free from the central star's gravitational pull. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\] \ud83d\udd2c Derivation of Each Velocity 1. First Cosmic Velocity (Orbital Velocity) The orbital velocity is the velocity needed for an object to move in a stable circular orbit around a celestial body. The centripetal force required for a circular orbit is provided by the gravitational force: \\[ F_c = \\frac{mv^2}{r}, \\quad F_g = \\frac{GMm}{r^2} \\] Equating the forces: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity (Escape Velocity) The escape velocity is the speed needed to break free from the gravitational pull of a celestial body, without any additional propulsion. The energy needed to escape is equal to the kinetic energy required to overcome the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity The third cosmic velocity is the velocity needed to escape the gravitational influence of the entire solar system or any other star system. It is derived from the concept of gravitational potential energy of the system. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\] \ud83d\udd0d Parameters Affecting the Cosmic Velocities The cosmic velocities depend on two key parameters: Mass ( \\(M\\) ) of the celestial body : Larger masses increase the required velocities. Radius ( \\(r\\) ) of the celestial body : Larger radii (i.e., larger distances) reduce the required velocities. \ud83c\udf0d Calculating Escape and Orbital Velocities for Earth, Mars, and Jupiter Let's calculate the escape and orbital velocities for Earth, Mars, and Jupiter using the formulas derived above. The constants we'll use are: Gravitational constant ( \\(G\\) ) = \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Mass and radius of planets (approximations): Earth: \\(M_\\text{Earth} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Earth} = 6.371 \\times 10^6 \\, \\text{m}\\) Mars: \\(M_\\text{Mars} = 0.64171 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Mars} = 3.396 \\times 10^6 \\, \\text{m}\\) Jupiter: \\(M_\\text{Jupiter} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(r_\\text{Jupiter} = 6.991 \\times 10^7 \\, \\text{m}\\) \ud83e\uddea Python Code for Calculations and Visualization import numpy as np import matplotlib.pyplot as plt # Constants AU = 1.496e11 # 1 Astronomical Unit in meters (average Earth-Sun distance) radius = AU # Create theta array for orbit (0 to 2\u03c0) theta = np.linspace(0, 2 * np.pi, 1000) # Parametric equations for the circular orbit x = radius * np.cos(theta) y = radius * np.sin(theta) # Plotting plt.figure(figsize=(8, 8)) plt.plot(x, y, color='mediumseagreen', linewidth=2.5, label=f'Orbit Radius = {radius/1e6:.0f} km') plt.scatter(0, 0, color='gold', s=300, label='\u2600\ufe0f Sun Position', edgecolors='darkorange', linewidths=2, zorder=5) # Styling plt.title('\ud83c\udf0d Orbital Path around the Sun', fontsize=16, weight='bold') plt.xlabel('x (m)', fontsize=12) plt.ylabel('y (m)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.axis('equal') plt.legend(loc='upper center', fontsize=10, frameon=True, shadow=True) # Optional: dark background (uncomment if you want it) # plt.style.use('dark_background') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"\ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"Kepler's Third Law states: The square of the orbital period ( \\(T\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r\\) ) of its orbit. For circular orbits , the derivation proceeds from Newton\u2019s Law of Gravitation and centripetal force :","title":"\ud83e\udde0 Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-equating-gravitational-and-centripetal-forces","text":"Gravitational force: \\[ F_g = \\frac{GMm}{r^2} \\] Centripetal force: \\[ F_c = \\frac{mv^2}{r} \\] Equating both: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Mass \\(m\\) cancels: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] Solve for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\]","title":"1. Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-orbital-period-from-velocity","text":"The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\]","title":"2. Orbital Period from Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-result-keplers-third-law","text":"\\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\Rightarrow T^2 \\propto r^3 \\]","title":"\u2705 Final Result (Kepler\u2019s Third Law):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#significance-of-the-t2-propto-r3-relationship","text":"Helps determine distances of planets from stars. Enables estimation of masses of celestial bodies. Crucial in calculating satellite orbits , spacecraft trajectories . Valid for any object orbiting under gravity in a central field.","title":"\ud83c\udf0c Significance of the \\(T^2 \\propto r^3\\) Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-applications","text":"Examples where Kepler's Law applies: Moon around Earth \\(r = 3.84 \\times 10^8\\) m, \\(T = 27.3\\) days Planets in Solar System Approximate relation holds: \\(T^2 \\propto r^3\\) \\(T\\) in Earth years, \\(r\\) in AU","title":"\ud83c\udf0d Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) \u2014 from 0.3 AU to 30 AU radii = np.linspace(0.3, 30, 300) * 1.496e11 # Calculate orbital periods using Kepler's Third Law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Prepare figure plt.figure(figsize=(10, 6)) colors = plt.cm.plasma(np.linspace(0, 1, len(radii))) # Gradient color map # Plot with colorful dots plt.scatter(radii**3, T**2, c=colors, s=10, edgecolor='black', linewidth=0.2, alpha=0.8, label=r'$\\mathbf{T^2 \\propto r^3}$') # Real Solar System planets (approximate data) planet_data = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86), 'Saturn': (9.58, 29.46), 'Uranus': (19.22, 84.01), 'Neptune': (30.05, 164.8) } # Plot planet points for planet, (r_au, T_years) in planet_data.items(): r3 = (r_au * 1.496e11) ** 3 T2 = (T_years * 365.25 * 24 * 3600) ** 2 plt.scatter(r3, T2, color='black', s=40, marker='o', label=planet) plt.annotate(planet, (r3, T2), textcoords=\"offset points\", xytext=(5, 5), fontsize=8) # Axis labels plt.xlabel(r'$r^3 \\, (m^3)$', fontsize=12) plt.ylabel(r'$T^2 \\, (s^2)$', fontsize=12) plt.title('\ud83c\udf0d Kepler\\'s Third Law with Planetary Orbits', fontsize=14) plt.grid(True, linestyle='--', alpha=0.5) # Custom legend handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) # Remove duplicates plt.legend(by_label.values(), by_label.keys(), fontsize=8, loc='upper left') plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\udcd8 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#defining-the-first-second-and-third-cosmic-velocities","text":"The cosmic velocities are the speeds needed to escape or orbit a celestial body. There are three important cosmic velocities: First Cosmic Velocity : The velocity needed to orbit a celestial body in a circular orbit at the surface level. This is also called the orbital velocity . Formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., Earth, Mars, etc.), - \\(r\\) is the radius of the celestial body. Second Cosmic Velocity : The velocity needed to escape the gravitational pull of a celestial body. This is also known as the escape velocity . Formula: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(r\\) is the distance from the center of the celestial body, - \\(M\\) is the mass of the celestial body, - \\(G\\) is the gravitational constant. Third Cosmic Velocity : The velocity required to escape the gravitational influence of the entire solar system or any star system. This velocity is needed to break free from the central star's gravitational pull. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\]","title":"\ud83e\udde0 Defining the First, Second, and Third Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-each-velocity","text":"","title":"\ud83d\udd2c Derivation of Each Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-first-cosmic-velocity-orbital-velocity","text":"The orbital velocity is the velocity needed for an object to move in a stable circular orbit around a celestial body. The centripetal force required for a circular orbit is provided by the gravitational force: \\[ F_c = \\frac{mv^2}{r}, \\quad F_g = \\frac{GMm}{r^2} \\] Equating the forces: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-second-cosmic-velocity-escape-velocity","text":"The escape velocity is the speed needed to break free from the gravitational pull of a celestial body, without any additional propulsion. The energy needed to escape is equal to the kinetic energy required to overcome the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-third-cosmic-velocity","text":"The third cosmic velocity is the velocity needed to escape the gravitational influence of the entire solar system or any other star system. It is derived from the concept of gravitational potential energy of the system. Formula: \\[ v_3 = \\sqrt{\\frac{3GM}{r}} \\]","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#parameters-affecting-the-cosmic-velocities","text":"The cosmic velocities depend on two key parameters: Mass ( \\(M\\) ) of the celestial body : Larger masses increase the required velocities. Radius ( \\(r\\) ) of the celestial body : Larger radii (i.e., larger distances) reduce the required velocities.","title":"\ud83d\udd0d Parameters Affecting the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-escape-and-orbital-velocities-for-earth-mars-and-jupiter","text":"Let's calculate the escape and orbital velocities for Earth, Mars, and Jupiter using the formulas derived above. The constants we'll use are: Gravitational constant ( \\(G\\) ) = \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) Mass and radius of planets (approximations): Earth: \\(M_\\text{Earth} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Earth} = 6.371 \\times 10^6 \\, \\text{m}\\) Mars: \\(M_\\text{Mars} = 0.64171 \\times 10^{24} \\, \\text{kg}\\) , \\(r_\\text{Mars} = 3.396 \\times 10^6 \\, \\text{m}\\) Jupiter: \\(M_\\text{Jupiter} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(r_\\text{Jupiter} = 6.991 \\times 10^7 \\, \\text{m}\\)","title":"\ud83c\udf0d Calculating Escape and Orbital Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-calculations-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants AU = 1.496e11 # 1 Astronomical Unit in meters (average Earth-Sun distance) radius = AU # Create theta array for orbit (0 to 2\u03c0) theta = np.linspace(0, 2 * np.pi, 1000) # Parametric equations for the circular orbit x = radius * np.cos(theta) y = radius * np.sin(theta) # Plotting plt.figure(figsize=(8, 8)) plt.plot(x, y, color='mediumseagreen', linewidth=2.5, label=f'Orbit Radius = {radius/1e6:.0f} km') plt.scatter(0, 0, color='gold', s=300, label='\u2600\ufe0f Sun Position', edgecolors='darkorange', linewidths=2, zorder=5) # Styling plt.title('\ud83c\udf0d Orbital Path around the Sun', fontsize=16, weight='bold') plt.xlabel('x (m)', fontsize=12) plt.ylabel('y (m)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.axis('equal') plt.legend(loc='upper center', fontsize=10, frameon=True, shadow=True) # Optional: dark background (uncomment if you want it) # plt.style.use('dark_background') plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Code for Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Define the Concepts \ud83d\ude80 First Cosmic Velocity \u2014 Orbital Velocity Definition : The minimum velocity required for a body to stay in a stable circular orbit around a celestial object (like Earth) without propulsion. Physical Meaning : At this speed, the gravitational pull provides exactly the centripetal force needed for circular motion. A satellite moving at this speed remains in orbit just above the surface. \ud83c\udf0d Second Cosmic Velocity \u2014 Escape Velocity Definition : The minimum velocity needed to break free from the gravitational field of a celestial body without further propulsion. Physical Meaning : If a spacecraft reaches this velocity, it will escape the planet's gravity and not return, unless acted upon by another force. It is independent of the direction of launch (ignoring atmosphere and rotation). \ud83c\udf0c Third Cosmic Velocity \u2014 Interstellar Escape Velocity Definition : The minimum velocity required to escape the gravitational influence of the entire star system (e.g., Sun + planets). Physical Meaning : This is the speed needed to leave the solar system entirely . Used in planning interstellar missions like Voyager 1 & 2 . \ud83d\udcd0 Mathematical Analysis 1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity) Derived from equating centripetal force and gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Parameters : \\(G\\) : Gravitational constant \\(r\\) : Radius from center of mass (typically planet\u2019s radius for low orbit) 2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity) Derived from conservation of energy: Total mechanical energy at escape = 0 (kinetic = gravitational potential energy) \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}} \\] Note : \\(v_2 = \\sqrt{2} \\cdot v_1\\) 3\ufe0f\u20e3 Third Cosmic Velocity (Interstellar Escape) More complex derivation involving solar system dynamics. Escape velocity from Sun at Earth's orbit: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] If starting from Earth, subtract Earth's orbital velocity (~29.78 km/s): \\[ v_{3,\\text{from Earth}} = v_3 - v_{\\text{Earth orbit}} \\] \ud83d\udcca Parameter Effects Mass ( \\(M\\) ) : Directly increases velocity \u2014 more massive body requires more speed to escape. Radius ( \\(r\\) ) : Inversely proportional \u2014 closer to center means stronger gravity, hence higher velocity. Gravitational constant ( \\(G\\) ) : A fixed universal constant. \ud83d\udd01 Comparison Table Velocity Type Formula Depends On First Cosmic ( \\(v_1\\) ) \\(\\sqrt{\\frac{GM}{r}}\\) Mass, Radius Second Cosmic ( \\(v_2\\) ) \\(\\sqrt{\\frac{2GM}{r}}\\) Mass, Radius Third Cosmic ( \\(v_3\\) ) \\(\\sqrt{\\frac{2GM_{\\odot}}{r}}\\) Sun's Mass, Distance \ud83c\udf0c Cosmic Velocities \u2013 Calculations and Visualizations \ud83c\udfaf Objective Calculate the first , second , and third cosmic velocities for the following celestial bodies: Earth Mars Jupiter Create visualizations to compare these velocities across planets. \ud83e\uddee Formulas Used Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}\\) First Cosmic Velocity: Orbital Velocity, Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body without propulsion., Physical Meaning: Balances centripetal force and gravitational force., Object \"falls around\" the planet, never reaching the surface., , Derivation:, \\[ F{\\text{gravity}} = F{\\text{centripetal}} \\ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{R}} \\] Where: \\(G\\) = Gravitational constant \\(\\approx 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) , \\(M\\) = Mass of the celestial body, \\(R\\) = Radius from the center of the body, \ud83e\ude90 Second Cosmic Velocity: Escape Velocity, Definition: The minimum velocity needed to escape the gravitational field of a celestial body without further propulsion., Physical Meaning: Reaches a point at infinity with zero kinetic energy remaining., Not an orbit \u2014 a one-way departure from the gravitational pull., , Derivation:, From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] \ud83d\udd0e Note: Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity. \ud83c\udf1e Third Cosmic Velocity: Solar System Escape Velocity, Definition: The minimum velocity required to escape the Sun\u2019s gravitational field starting from a planet\u2019s surface., Physical Meaning: Combines: Escape velocity from the planet., Additional velocity to escape the Sun\u2019s pull from the planet\u2019s orbit., , , Approximate Formula:, \\[ v{\\text{total}}^2 = v{\\text{planet-escape}}^2 + v{\\text{sun-orbit}}^2 \\] Where: \\(v, {\\text{planet-escape}} = \\sqrt{\\frac{2GM_p}{Rp}}\\) \\(v, {\\text{sun-orbit}} = \\sqrt{\\frac{2GM_s}{r}}\\) \\(M_p\\) : Mass of the planet, \\(R_p\\) : Radius of the planet, \\(M_s\\) : Mass of the Sun, \\(r\\) : Distance from the planet to the Sun \ud83e\udde0 Parameters \\(M\\) : Mass of the planet \\(r\\) : Radius of the planet \\(M_{\\odot}\\) : Mass of the Sun \\(R_{\\text{orbit}}\\) : Distance from Sun (orbital radius of the planet) \ud83d\udc0d Python-Visual Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # kg # Planetary data planets = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'orbit_radius': 1.496e11}, 'Mars': {'mass': 6.4171e23, 'radius': 3.3895e6, 'orbit_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'orbit_radius': 7.785e11} } # Storage planet_names = [] v1_values = [] v2_values = [] v3_values = [] # Calculation for name, data in planets.items(): M = data['mass'] r = data['radius'] R_orbit = data['orbit_radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) v3 = np.sqrt(2 * G * M_sun / R_orbit) planet_names.append(name) v1_values.append(v1 / 1000) # km/s v2_values.append(v2 / 1000) v3_values.append(v3 / 1000) # Set up better visualization fig, ax = plt.subplots(figsize=(10, 6)) ax.set_facecolor('whitesmoke') colors = ['deepskyblue', 'orange', 'limegreen'] x_positions = np.arange(len(planet_names)) * 3 # spacing between planets # Plot each velocity as a vertical line (\"tower\") for i, name in enumerate(planet_names): xpos = x_positions[i] ax.vlines(xpos - 0.5, 0, v1_values[i], color=colors[0], lw=6, label='1st Cosmic' if i == 0 else \"\") ax.vlines(xpos, 0, v2_values[i], color=colors[1], lw=6, label='2nd Cosmic' if i == 0 else \"\") ax.vlines(xpos + 0.5, 0, v3_values[i], color=colors[2], lw=6, label='3rd Cosmic' if i == 0 else \"\") # Add labels ax.text(xpos - 0.5, v1_values[i] + 0.3, f\"{v1_values[i]:.1f}\", ha='center', color=colors[0], fontsize=9) ax.text(xpos, v2_values[i] + 0.3, f\"{v2_values[i]:.1f}\", ha='center', color=colors[1], fontsize=9) ax.text(xpos + 0.5, v3_values[i] + 0.3, f\"{v3_values[i]:.1f}\", ha='center', color=colors[2], fontsize=9) # Planet label ax.text(xpos, -1.5, name, ha='center', fontsize=12, fontweight='bold') # Aesthetics ax.set_xlim(-1, x_positions[-1] + 2) ax.set_ylim(0, max(v2_values) + 5) ax.set_ylabel(\"Velocity (km/s)\", fontsize=12) ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\", fontsize=14, fontweight='bold') ax.legend(loc='upper right') ax.grid(True, axis='y', linestyle='--', alpha=0.5) plt.tight_layout() plt.show() \ud83d\ude80 Discussion: Importance of Cosmic Velocities in Space Missions Understanding cosmic velocities is critical in planning space missions. The three main velocities \u2014 first , second , and third cosmic velocities \u2014 define key thresholds in spaceflight dynamics. \ud83c\udf00 First Cosmic Velocity ( \\(v_1\\) ): Orbital Velocity Definition : Minimum velocity needed to place a satellite into stable circular orbit around a planet. Equation : \\( \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) where: \\(G\\) = gravitational constant \\(M\\) = mass of the planet \\(r\\) = radius from the planet's center Use case : Placing satellites like the ISS (International Space Station) into low Earth orbit . Used by companies like SpaceX and NASA for communication and Earth observation satellites. \ud83d\ude80 Second Cosmic Velocity ( \\(v_2\\) ): Escape Velocity Definition : Minimum velocity to completely escape a planet's gravitational field. Equation : \\( \\(v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}}\\) \\) Use case : Used in interplanetary missions , such as Mars rovers (Perseverance, Curiosity) . Apollo missions had to reach this speed to leave Earth and travel to the Moon. \ud83c\udf0c Third Cosmic Velocity ( \\(v_3\\) ): Interstellar Escape Velocity Definition : Minimum velocity to escape the gravitational pull of the Sun from Earth\u2019s orbit. Equation : \\( \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}}\\) \\) where: \\(M_{\\odot}\\) = mass of the Sun \\(R\\) = orbital radius (e.g., 1 AU for Earth) Use case : Missions like Voyager 1 and Voyager 2 (launched in 1977) exceeded this speed. These probes are now traveling through interstellar space , having exited the heliosphere. \ud83d\udef0\ufe0f Summary of Practical Implications \\(v_1\\) : Required to maintain satellite orbits . \\(v_2\\) : Required to conduct planetary transfers or leave planets. \\(v_3\\) : Required to exit the Solar System and explore interstellar space. \ud83c\udf0d Real-World Examples Mission Velocity Used Purpose ISS Launches (e.g., SpaceX) \\(v_1\\) Satellite orbiting Earth Mars Rovers (Perseverance) \\(v_2\\) Escape Earth to reach Mars Voyager 1/2 (NASA, 1977) \\(v_3\\) Escape the Solar System \ud83d\udca1 These concepts not only define theoretical thresholds but also directly inform mission planning, fuel budgeting, and spacecraft engineering .","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#define-the-concepts","text":"","title":"Define the Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum velocity required for a body to stay in a stable circular orbit around a celestial object (like Earth) without propulsion. Physical Meaning : At this speed, the gravitational pull provides exactly the centripetal force needed for circular motion. A satellite moving at this speed remains in orbit just above the surface.","title":"\ud83d\ude80 First Cosmic Velocity \u2014 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : The minimum velocity needed to break free from the gravitational field of a celestial body without further propulsion. Physical Meaning : If a spacecraft reaches this velocity, it will escape the planet's gravity and not return, unless acted upon by another force. It is independent of the direction of launch (ignoring atmosphere and rotation).","title":"\ud83c\udf0d Second Cosmic Velocity \u2014 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape-velocity","text":"Definition : The minimum velocity required to escape the gravitational influence of the entire star system (e.g., Sun + planets). Physical Meaning : This is the speed needed to leave the solar system entirely . Used in planning interstellar missions like Voyager 1 & 2 .","title":"\ud83c\udf0c Third Cosmic Velocity \u2014 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-analysis","text":"","title":"\ud83d\udcd0 Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"Derived from equating centripetal force and gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Parameters : \\(G\\) : Gravitational constant \\(r\\) : Radius from center of mass (typically planet\u2019s radius for low orbit)","title":"1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"Derived from conservation of energy: Total mechanical energy at escape = 0 (kinetic = gravitational potential energy) \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{r}} \\] Note : \\(v_2 = \\sqrt{2} \\cdot v_1\\)","title":"2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-escape","text":"More complex derivation involving solar system dynamics. Escape velocity from Sun at Earth's orbit: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] If starting from Earth, subtract Earth's orbital velocity (~29.78 km/s): \\[ v_{3,\\text{from Earth}} = v_3 - v_{\\text{Earth orbit}} \\]","title":"3\ufe0f\u20e3 Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameter-effects","text":"Mass ( \\(M\\) ) : Directly increases velocity \u2014 more massive body requires more speed to escape. Radius ( \\(r\\) ) : Inversely proportional \u2014 closer to center means stronger gravity, hence higher velocity. Gravitational constant ( \\(G\\) ) : A fixed universal constant.","title":"\ud83d\udcca Parameter Effects"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-table","text":"Velocity Type Formula Depends On First Cosmic ( \\(v_1\\) ) \\(\\sqrt{\\frac{GM}{r}}\\) Mass, Radius Second Cosmic ( \\(v_2\\) ) \\(\\sqrt{\\frac{2GM}{r}}\\) Mass, Radius Third Cosmic ( \\(v_3\\) ) \\(\\sqrt{\\frac{2GM_{\\odot}}{r}}\\) Sun's Mass, Distance","title":"\ud83d\udd01 Comparison Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-calculations-and-visualizations","text":"","title":"\ud83c\udf0c Cosmic Velocities \u2013 Calculations and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#objective","text":"Calculate the first , second , and third cosmic velocities for the following celestial bodies: Earth Mars Jupiter Create visualizations to compare these velocities across planets.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_2/#formulas-used","text":"Gravitational constant: \\(G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}\\) First Cosmic Velocity: Orbital Velocity, Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body without propulsion., Physical Meaning: Balances centripetal force and gravitational force., Object \"falls around\" the planet, never reaching the surface., , Derivation:, \\[ F{\\text{gravity}} = F{\\text{centripetal}} \\ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{R}} \\] Where: \\(G\\) = Gravitational constant \\(\\approx 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) , \\(M\\) = Mass of the celestial body, \\(R\\) = Radius from the center of the body, \ud83e\ude90 Second Cosmic Velocity: Escape Velocity, Definition: The minimum velocity needed to escape the gravitational field of a celestial body without further propulsion., Physical Meaning: Reaches a point at infinity with zero kinetic energy remaining., Not an orbit \u2014 a one-way departure from the gravitational pull., , Derivation:, From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] \ud83d\udd0e Note: Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity. \ud83c\udf1e Third Cosmic Velocity: Solar System Escape Velocity, Definition: The minimum velocity required to escape the Sun\u2019s gravitational field starting from a planet\u2019s surface., Physical Meaning: Combines: Escape velocity from the planet., Additional velocity to escape the Sun\u2019s pull from the planet\u2019s orbit., , , Approximate Formula:, \\[ v{\\text{total}}^2 = v{\\text{planet-escape}}^2 + v{\\text{sun-orbit}}^2 \\] Where: \\(v, {\\text{planet-escape}} = \\sqrt{\\frac{2GM_p}{Rp}}\\) \\(v, {\\text{sun-orbit}} = \\sqrt{\\frac{2GM_s}{r}}\\) \\(M_p\\) : Mass of the planet, \\(R_p\\) : Radius of the planet, \\(M_s\\) : Mass of the Sun, \\(r\\) : Distance from the planet to the Sun","title":"\ud83e\uddee Formulas Used"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"\\(M\\) : Mass of the planet \\(r\\) : Radius of the planet \\(M_{\\odot}\\) : Mass of the Sun \\(R_{\\text{orbit}}\\) : Distance from Sun (orbital radius of the planet)","title":"\ud83e\udde0 Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-visual-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # kg # Planetary data planets = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'orbit_radius': 1.496e11}, 'Mars': {'mass': 6.4171e23, 'radius': 3.3895e6, 'orbit_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'orbit_radius': 7.785e11} } # Storage planet_names = [] v1_values = [] v2_values = [] v3_values = [] # Calculation for name, data in planets.items(): M = data['mass'] r = data['radius'] R_orbit = data['orbit_radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) v3 = np.sqrt(2 * G * M_sun / R_orbit) planet_names.append(name) v1_values.append(v1 / 1000) # km/s v2_values.append(v2 / 1000) v3_values.append(v3 / 1000) # Set up better visualization fig, ax = plt.subplots(figsize=(10, 6)) ax.set_facecolor('whitesmoke') colors = ['deepskyblue', 'orange', 'limegreen'] x_positions = np.arange(len(planet_names)) * 3 # spacing between planets # Plot each velocity as a vertical line (\"tower\") for i, name in enumerate(planet_names): xpos = x_positions[i] ax.vlines(xpos - 0.5, 0, v1_values[i], color=colors[0], lw=6, label='1st Cosmic' if i == 0 else \"\") ax.vlines(xpos, 0, v2_values[i], color=colors[1], lw=6, label='2nd Cosmic' if i == 0 else \"\") ax.vlines(xpos + 0.5, 0, v3_values[i], color=colors[2], lw=6, label='3rd Cosmic' if i == 0 else \"\") # Add labels ax.text(xpos - 0.5, v1_values[i] + 0.3, f\"{v1_values[i]:.1f}\", ha='center', color=colors[0], fontsize=9) ax.text(xpos, v2_values[i] + 0.3, f\"{v2_values[i]:.1f}\", ha='center', color=colors[1], fontsize=9) ax.text(xpos + 0.5, v3_values[i] + 0.3, f\"{v3_values[i]:.1f}\", ha='center', color=colors[2], fontsize=9) # Planet label ax.text(xpos, -1.5, name, ha='center', fontsize=12, fontweight='bold') # Aesthetics ax.set_xlim(-1, x_positions[-1] + 2) ax.set_ylim(0, max(v2_values) + 5) ax.set_ylabel(\"Velocity (km/s)\", fontsize=12) ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\", fontsize=14, fontweight='bold') ax.legend(loc='upper right') ax.grid(True, axis='y', linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python-Visual Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-importance-of-cosmic-velocities-in-space-missions","text":"Understanding cosmic velocities is critical in planning space missions. The three main velocities \u2014 first , second , and third cosmic velocities \u2014 define key thresholds in spaceflight dynamics.","title":"\ud83d\ude80 Discussion: Importance of Cosmic Velocities in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1-orbital-velocity","text":"Definition : Minimum velocity needed to place a satellite into stable circular orbit around a planet. Equation : \\( \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\) where: \\(G\\) = gravitational constant \\(M\\) = mass of the planet \\(r\\) = radius from the planet's center Use case : Placing satellites like the ISS (International Space Station) into low Earth orbit . Used by companies like SpaceX and NASA for communication and Earth observation satellites.","title":"\ud83c\udf00 First Cosmic Velocity (\\(v_1\\)): Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2-escape-velocity","text":"Definition : Minimum velocity to completely escape a planet's gravitational field. Equation : \\( \\(v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}}\\) \\) Use case : Used in interplanetary missions , such as Mars rovers (Perseverance, Curiosity) . Apollo missions had to reach this speed to leave Earth and travel to the Moon.","title":"\ud83d\ude80 Second Cosmic Velocity (\\(v_2\\)): Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3-interstellar-escape-velocity","text":"Definition : Minimum velocity to escape the gravitational pull of the Sun from Earth\u2019s orbit. Equation : \\( \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{R}}\\) \\) where: \\(M_{\\odot}\\) = mass of the Sun \\(R\\) = orbital radius (e.g., 1 AU for Earth) Use case : Missions like Voyager 1 and Voyager 2 (launched in 1977) exceeded this speed. These probes are now traveling through interstellar space , having exited the heliosphere.","title":"\ud83c\udf0c Third Cosmic Velocity (\\(v_3\\)): Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-of-practical-implications","text":"\\(v_1\\) : Required to maintain satellite orbits . \\(v_2\\) : Required to conduct planetary transfers or leave planets. \\(v_3\\) : Required to exit the Solar System and explore interstellar space.","title":"\ud83d\udef0\ufe0f Summary of Practical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#real-world-examples","text":"Mission Velocity Used Purpose ISS Launches (e.g., SpaceX) \\(v_1\\) Satellite orbiting Earth Mars Rovers (Perseverance) \\(v_2\\) Escape Earth to reach Mars Voyager 1/2 (NASA, 1977) \\(v_3\\) Escape the Solar System \ud83d\udca1 These concepts not only define theoretical thresholds but also directly inform mission planning, fuel budgeting, and spacecraft engineering .","title":"\ud83c\udf0d Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth \ud83d\udd0d Understanding the Physics Concepts \u2696\ufe0f Newton\u2019s Law of Universal Gravitation The gravitational force \\(F\\) between two masses is given by: \\[ F = G\\frac{m_1 m_2}{r^2} \\] where: - \\(G \\approx 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) is the gravitational constant - \\(m_1\\) and \\(m_2\\) are the masses - \\(r\\) is the distance between the centers of the two masses For a small object (payload) near Earth: \\[ F = G\\frac{M_{\\oplus} m}{r^2} \\] where \\(M_{\\oplus}\\) is Earth's mass, \\(m\\) is the payload mass, and \\(r\\) is the distance from Earth's center. \ud83c\udf0c Types of Trajectories-Visual The nature of the trajectory depends on the total mechanical energy \\(E\\) : \\[ E = \\frac{1}{2}mv^2 - \\frac{GM_{\\oplus}m}{r} \\] Elliptical Orbit : \\(E < 0\\) Parabolic Escape Trajectory : \\(E = 0\\) Hyperbolic Escape Trajectory : \\(E > 0\\) Velocity thresholds: - Orbital Velocity (for circular orbit): \\[ v_{\\text{orb}} = \\sqrt{\\frac{GM_{\\oplus}}{r}} \\] Escape Velocity : \\[ v_{\\text{esc}} = \\sqrt{2} \\cdot v_{\\text{orb}} = \\sqrt{\\frac{2GM_{\\oplus}}{r}} \\] \ud83e\ude90 Kepler's Laws (for Elliptical Orbits) First Law (Elliptical Orbits) : Planets move in ellipses with the Sun (or central mass) at one focus. Second Law (Equal Areas in Equal Times) : A line joining a planet and the Sun sweeps out equal areas in equal intervals of time. Third Law (Harmonic Law) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] \ud83e\uddee Defining the Problem Mathematically \ud83e\udded Variables and Initial Conditions Let the payload be released from a moving rocket at altitude \\(h\\) . Define: \\(r_0 = R_{\\oplus} + h\\) : Initial radial distance from Earth's center \\(\\vec{v}_0\\) : Initial velocity vector of the payload \\(\\theta\\) : Angle between velocity and local horizontal \\(m\\) : Mass of payload (may cancel out in equations) \\(\\vec{r}(t)\\) : Position vector as a function of time \\(\\vec{v}(t)\\) : Velocity vector as a function of time \ud83e\udded Equations of Motion under Gravity Let the acceleration be determined only by gravity (neglecting drag and other forces). The equation of motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is a second-order ordinary differential equation (ODE) Can be solved numerically using methods like Runge-Kutta \ud83e\uddfe Summary of Key Constants \\(G = 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) \\(M_{\\oplus} = 5.972 \\times 10^{24}~\\text{kg}\\) \\(R_{\\oplus} = 6.371 \\times 10^6~\\text{m}\\) \ud83e\uddee Chapter 3: Numerical Simulation of Payload Trajectory \ud83e\uddf0 Choose a Numerical Method To simulate the motion of a payload under Earth's gravity, we need to solve the second-order differential equation : \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is equivalent to solving a system of first-order ODEs by introducing velocity as a separate state: Let: \\(\\vec{r}(t)\\) : position vector \\(\\vec{v}(t) = \\frac{d\\vec{r}}{dt}\\) : velocity vector Then: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] \u2705 Method Selection Euler\u2019s Method : Simple but inaccurate for orbital simulations. Runge-Kutta 4th Order (RK4) : Offers a good balance of accuracy and efficiency . Chosen for this simulation. \u23f1\ufe0f Define Simulation Parameters We need to define: Initial position \\(\\vec{r}_0\\) (depends on altitude \\(h\\) ) Initial velocity \\(\\vec{v}_0\\) (depends on angle \\(\\theta\\) ) Gravitational constant \\(G\\) and Earth's mass \\(M_{\\oplus}\\) Time step \\(\\Delta t\\) Total simulation time \\(T\\) \ud83d\udc0d Implementing the Simulation in Python \ud83c\udfaf Objective: Simulate and visualize the trajectory of a payload released near Earth using RK4. \u2705 Inputs: Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Release angle \\(\\theta\\) Altitude \\(h\\) Time step \\(\\Delta t\\) \ud83d\udce6 Output: Time-evolving position vectors \\(\\vec{r}(t)\\) A 2D trajectory plot in space import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Earth mass (kg) R_earth = 6.371e6 # Earth radius (m) # Simulation setup altitude = 300e3 # Initial altitude (m) r0 = np.array([R_earth + altitude, 0]) # Initial position (m) angles = [0] # Straight launch velocities = [7300, 7500, 7700, 7900, 8100, 8300] # Different speeds (m/s) dt = 1.5 # Time step (s) T = 5500 # Total simulation time (s) steps = int(T / dt) # Define acceleration under gravity def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 integrator def rk4_orbit(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = acceleration(r[i]) k1r = v[i] k2v = acceleration(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = acceleration(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = acceleration(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: r = r[:i+2] # Stop at impact break return r # Plotting plt.figure(figsize=(9, 9)) colors = ['#0077b6', '#00b4d8', '#90e0ef', '#ffb703', '#fb8500', '#d00000'] for v_mag, color in zip(velocities, colors): angle = np.radians(20) # slight angle v0 = v_mag * np.array([np.cos(angle), np.sin(angle)]) trajectory = rk4_orbit(r0, v0) plt.plot(trajectory[:, 0] / 1e6, trajectory[:, 1] / 1e6, label=f'$v = {v_mag}$ m/s', linewidth=2.0, color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='#6fa8dc', zorder=0) plt.gca().add_artist(earth) # Style the plot plt.title(\"\ud83e\ude90 Stylized Payload Trajectories (Different Velocities)\", fontsize=16, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend(loc='upper right', fontsize=10) plt.tight_layout() plt.show() \ud83d\ude80 Visualizing and Analyzing Payload Trajectories This section presents the visual and analytical interpretation of simulated trajectories for payloads released near Earth under the influence of gravity. \ud83c\udfaf Objectives \ud83d\udcc8 Plot and analyze 2D trajectories of payloads. \ud83c\udf00 Classify orbits: elliptical , hyperbolic , and suborbital . \ud83d\udca1 Highlight critical velocities like orbital and escape velocity . \ud83e\udde0 Draw practical conclusions for space missions (e.g., reentry, orbital insertion). \ud83d\udcca Visualizing the Results \u2733\ufe0f Key Quantities Orbital velocity at low Earth orbit: $$ v_{orbital} = \\sqrt{\\frac{GM}{R + h}} $$ Escape velocity from the same altitude: $$ v_{escape} = \\sqrt{\\frac{2GM}{R + h}} $$ Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of Earth, - \\(R\\) = radius of Earth, - \\(h\\) = altitude of payload. \ud83d\udcd0 Trajectory Types Bound orbits : Elliptical paths where \\(E < 0\\) . Escape trajectories : Hyperbolic paths where \\(E > 0\\) . Reentry/Suborbital : Short arcs falling back to Earth. \ud83d\udd27 Plotting in Python (2D Example) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) dt = 1.5 T = 6000 steps = int(T / dt) # Function: Gravitational acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 Integrator def rk4(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = gravity(r[i]) k1r = v[i] k2v = gravity(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = gravity(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = gravity(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: return r[:i+2] return r # Simulation velocities = [7200, 7600, 8000, 8400, 11200] # m/s colors = ['blue', 'green', 'orange', 'crimson', 'purple'] labels = ['Suborbital', 'Low Orbit', 'Elliptical', 'High Elliptical', 'Escape'] plt.figure(figsize=(9, 9)) for v_mag, color, label in zip(velocities, colors, labels): v0 = v_mag * np.array([0, 1]) path = rk4(r0, v0) plt.plot(path[:, 0]/1e6, path[:, 1]/1e6, label=f'{label}: {v_mag} m/s', color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='skyblue', zorder=0) plt.gca().add_artist(earth) # Plot styling plt.title(\"\ud83d\udd2d Payload Trajectories from LEO\", fontsize=15, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend() plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#understanding-the-physics-concepts","text":"","title":"\ud83d\udd0d Understanding the Physics Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational force \\(F\\) between two masses is given by: \\[ F = G\\frac{m_1 m_2}{r^2} \\] where: - \\(G \\approx 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) is the gravitational constant - \\(m_1\\) and \\(m_2\\) are the masses - \\(r\\) is the distance between the centers of the two masses For a small object (payload) near Earth: \\[ F = G\\frac{M_{\\oplus} m}{r^2} \\] where \\(M_{\\oplus}\\) is Earth's mass, \\(m\\) is the payload mass, and \\(r\\) is the distance from Earth's center.","title":"\u2696\ufe0f Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories-visual","text":"The nature of the trajectory depends on the total mechanical energy \\(E\\) : \\[ E = \\frac{1}{2}mv^2 - \\frac{GM_{\\oplus}m}{r} \\] Elliptical Orbit : \\(E < 0\\) Parabolic Escape Trajectory : \\(E = 0\\) Hyperbolic Escape Trajectory : \\(E > 0\\) Velocity thresholds: - Orbital Velocity (for circular orbit): \\[ v_{\\text{orb}} = \\sqrt{\\frac{GM_{\\oplus}}{r}} \\] Escape Velocity : \\[ v_{\\text{esc}} = \\sqrt{2} \\cdot v_{\\text{orb}} = \\sqrt{\\frac{2GM_{\\oplus}}{r}} \\]","title":"\ud83c\udf0c Types of Trajectories-Visual"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-laws-for-elliptical-orbits","text":"First Law (Elliptical Orbits) : Planets move in ellipses with the Sun (or central mass) at one focus. Second Law (Equal Areas in Equal Times) : A line joining a planet and the Sun sweeps out equal areas in equal intervals of time. Third Law (Harmonic Law) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\]","title":"\ud83e\ude90 Kepler's Laws (for Elliptical Orbits)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#defining-the-problem-mathematically","text":"","title":"\ud83e\uddee Defining the Problem Mathematically"},{"location":"1%20Physics/2%20Gravity/Problem_3/#variables-and-initial-conditions","text":"Let the payload be released from a moving rocket at altitude \\(h\\) . Define: \\(r_0 = R_{\\oplus} + h\\) : Initial radial distance from Earth's center \\(\\vec{v}_0\\) : Initial velocity vector of the payload \\(\\theta\\) : Angle between velocity and local horizontal \\(m\\) : Mass of payload (may cancel out in equations) \\(\\vec{r}(t)\\) : Position vector as a function of time \\(\\vec{v}(t)\\) : Velocity vector as a function of time","title":"\ud83e\udded Variables and Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-under-gravity","text":"Let the acceleration be determined only by gravity (neglecting drag and other forces). The equation of motion is: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is a second-order ordinary differential equation (ODE) Can be solved numerically using methods like Runge-Kutta","title":"\ud83e\udded Equations of Motion under Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-of-key-constants","text":"\\(G = 6.674 \\times 10^{-11}~\\text{N}\\cdot\\text{m}^2/\\text{kg}^2\\) \\(M_{\\oplus} = 5.972 \\times 10^{24}~\\text{kg}\\) \\(R_{\\oplus} = 6.371 \\times 10^6~\\text{m}\\)","title":"\ud83e\uddfe Summary of Key Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#chapter-3-numerical-simulation-of-payload-trajectory","text":"","title":"\ud83e\uddee Chapter 3: Numerical Simulation of Payload Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#choose-a-numerical-method","text":"To simulate the motion of a payload under Earth's gravity, we need to solve the second-order differential equation : \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\] This is equivalent to solving a system of first-order ODEs by introducing velocity as a separate state: Let: \\(\\vec{r}(t)\\) : position vector \\(\\vec{v}(t) = \\frac{d\\vec{r}}{dt}\\) : velocity vector Then: \\[ \\frac{d\\vec{r}}{dt} = \\vec{v}, \\quad \\frac{d\\vec{v}}{dt} = -\\frac{GM_{\\oplus}}{|\\vec{r}|^3} \\vec{r} \\]","title":"\ud83e\uddf0 Choose a Numerical Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#method-selection","text":"Euler\u2019s Method : Simple but inaccurate for orbital simulations. Runge-Kutta 4th Order (RK4) : Offers a good balance of accuracy and efficiency . Chosen for this simulation.","title":"\u2705 Method Selection"},{"location":"1%20Physics/2%20Gravity/Problem_3/#define-simulation-parameters","text":"We need to define: Initial position \\(\\vec{r}_0\\) (depends on altitude \\(h\\) ) Initial velocity \\(\\vec{v}_0\\) (depends on angle \\(\\theta\\) ) Gravitational constant \\(G\\) and Earth's mass \\(M_{\\oplus}\\) Time step \\(\\Delta t\\) Total simulation time \\(T\\)","title":"\u23f1\ufe0f Define Simulation Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#implementing-the-simulation-in-python","text":"","title":"\ud83d\udc0d Implementing the Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Simulate and visualize the trajectory of a payload released near Earth using RK4.","title":"\ud83c\udfaf Objective:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#inputs","text":"Initial position \\(\\vec{r}_0\\) Initial velocity \\(\\vec{v}_0\\) Release angle \\(\\theta\\) Altitude \\(h\\) Time step \\(\\Delta t\\)","title":"\u2705 Inputs:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output","text":"Time-evolving position vectors \\(\\vec{r}(t)\\) A 2D trajectory plot in space import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Earth mass (kg) R_earth = 6.371e6 # Earth radius (m) # Simulation setup altitude = 300e3 # Initial altitude (m) r0 = np.array([R_earth + altitude, 0]) # Initial position (m) angles = [0] # Straight launch velocities = [7300, 7500, 7700, 7900, 8100, 8300] # Different speeds (m/s) dt = 1.5 # Time step (s) T = 5500 # Total simulation time (s) steps = int(T / dt) # Define acceleration under gravity def acceleration(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 integrator def rk4_orbit(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = acceleration(r[i]) k1r = v[i] k2v = acceleration(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = acceleration(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = acceleration(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: r = r[:i+2] # Stop at impact break return r # Plotting plt.figure(figsize=(9, 9)) colors = ['#0077b6', '#00b4d8', '#90e0ef', '#ffb703', '#fb8500', '#d00000'] for v_mag, color in zip(velocities, colors): angle = np.radians(20) # slight angle v0 = v_mag * np.array([np.cos(angle), np.sin(angle)]) trajectory = rk4_orbit(r0, v0) plt.plot(trajectory[:, 0] / 1e6, trajectory[:, 1] / 1e6, label=f'$v = {v_mag}$ m/s', linewidth=2.0, color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='#6fa8dc', zorder=0) plt.gca().add_artist(earth) # Style the plot plt.title(\"\ud83e\ude90 Stylized Payload Trajectories (Different Velocities)\", fontsize=16, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend(loc='upper right', fontsize=10) plt.tight_layout() plt.show()","title":"\ud83d\udce6 Output:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualizing-and-analyzing-payload-trajectories","text":"This section presents the visual and analytical interpretation of simulated trajectories for payloads released near Earth under the influence of gravity.","title":"\ud83d\ude80 Visualizing and Analyzing Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objectives","text":"\ud83d\udcc8 Plot and analyze 2D trajectories of payloads. \ud83c\udf00 Classify orbits: elliptical , hyperbolic , and suborbital . \ud83d\udca1 Highlight critical velocities like orbital and escape velocity . \ud83e\udde0 Draw practical conclusions for space missions (e.g., reentry, orbital insertion).","title":"\ud83c\udfaf Objectives"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualizing-the-results","text":"","title":"\ud83d\udcca Visualizing the Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-quantities","text":"Orbital velocity at low Earth orbit: $$ v_{orbital} = \\sqrt{\\frac{GM}{R + h}} $$ Escape velocity from the same altitude: $$ v_{escape} = \\sqrt{\\frac{2GM}{R + h}} $$ Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of Earth, - \\(R\\) = radius of Earth, - \\(h\\) = altitude of payload.","title":"\u2733\ufe0f Key Quantities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types","text":"Bound orbits : Elliptical paths where \\(E < 0\\) . Escape trajectories : Hyperbolic paths where \\(E > 0\\) . Reentry/Suborbital : Short arcs falling back to Earth.","title":"\ud83d\udcd0 Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-in-python-2d-example","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) dt = 1.5 T = 6000 steps = int(T / dt) # Function: Gravitational acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # RK4 Integrator def rk4(r0, v0): r = np.zeros((steps, 2)) v = np.zeros((steps, 2)) r[0], v[0] = r0, v0 for i in range(steps - 1): k1v = gravity(r[i]) k1r = v[i] k2v = gravity(r[i] + 0.5 * dt * k1r) k2r = v[i] + 0.5 * dt * k1v k3v = gravity(r[i] + 0.5 * dt * k2r) k3r = v[i] + 0.5 * dt * k2v k4v = gravity(r[i] + dt * k3r) k4r = v[i] + dt * k3v r[i+1] = r[i] + dt/6 * (k1r + 2*k2r + 2*k3r + k4r) v[i+1] = v[i] + dt/6 * (k1v + 2*k2v + 2*k3v + k4v) if np.linalg.norm(r[i+1]) < R_earth: return r[:i+2] return r # Simulation velocities = [7200, 7600, 8000, 8400, 11200] # m/s colors = ['blue', 'green', 'orange', 'crimson', 'purple'] labels = ['Suborbital', 'Low Orbit', 'Elliptical', 'High Elliptical', 'Escape'] plt.figure(figsize=(9, 9)) for v_mag, color, label in zip(velocities, colors, labels): v0 = v_mag * np.array([0, 1]) path = rk4(r0, v0) plt.plot(path[:, 0]/1e6, path[:, 1]/1e6, label=f'{label}: {v_mag} m/s', color=color) # Draw Earth earth = plt.Circle((0, 0), R_earth / 1e6, color='skyblue', zorder=0) plt.gca().add_artist(earth) # Plot styling plt.title(\"\ud83d\udd2d Payload Trajectories from LEO\", fontsize=15, weight='bold') plt.xlabel(\"X Position (10\u2076 m)\", fontsize=12) plt.ylabel(\"Y Position (10\u2076 m)\", fontsize=12) plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.4) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udd27 Plotting in Python (2D Example)"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Interference Patterns on a Water Surface \u2013 Wave Modeling \ud83d\udd37 Step 1: Choosing a Regular Polygon We begin by choosing a regular polygon as the geometric base for placing wave sources. In this case, we select a: Square : A 4-sided regular polygon. Let the side length be normalized, and the center of the square be located at the origin \\((0,0)\\) . Then, the vertices (wave sources) are placed symmetrically around the origin: \ud83d\udd39 Vertex Coordinates (Wave Sources) Let the distance from the center to each vertex be \\(R\\) . Then the coordinates are: \\((x_1,y_1) = (R,R)\\) \\((x_2,y_2) = (-R,R)\\) \\((x_3,y_3) = (-R,-R)\\) \\((x_4,y_4) = (R,-R)\\) These correspond to the corners of a square centered at the origin. \ud83d\udcd0 Step 2: Define Wave Parameters We define the physical properties of each wave emitted from the sources: Amplitude : \\(A\\) Wavelength : \\(\\lambda\\) Frequency : \\(f\\) Angular Frequency : $$ \\omega = 2\\pi f $$ Wave Number : $$ k = \\frac{2\\pi}{\\lambda} $$ Initial Phase : \\(\\phi\\) (Assume same phase for all sources for coherence) \ud83e\uddee Step 3: Mathematical Model \u2013 Single Source The displacement of the water surface at point \\((x,y)\\) and time \\(t\\) from a single point source located at \\((x_0,y_0)\\) is given by: \\[ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) , \\(A\\) is the amplitude, \\(k\\) is the wave number, \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase. \ud83d\udcca Step 4: Superposition from Multiple Sources Since the waves from all sources are coherent and identical (same \\(A\\) , \\(k\\) , \\(f\\) , and \\(\\phi\\) ), the total surface displacement at any point \\((x,y)\\) and time \\(t\\) is: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} \\eta_i(x,y,t) \\] For a square, \\(N=4\\) , so: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{4} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos\\left(k r_i - \\omega t + \\phi\\right) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) for each source \\(i\\) . Python codes # \ud83d\udce6 Import required libraries import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image # \ud83d\udcd0 Define wave and simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength # \ud83c\udfaf Define source positions (Square centered at origin, side length 2R) R = 2.0 sources = [ ( R, R), # top-right (-R, R), # top-left (-R, -R), # bottom-left ( R, -R), # bottom-right ] # \ud83d\uddfa\ufe0f Set up spatial grid x = np.linspace(-5, 5, 300) y = np.linspace(-5, 5, 300) X, Y = np.meshgrid(x, y) # \ud83c\udf9e\ufe0f Set up the figure fig, ax = plt.subplots(figsize=(6, 5)) c = ax.pcolormesh(X, Y, np.zeros_like(X), shading='auto', cmap='viridis', vmin=-2, vmax=2) fig.colorbar(c, ax=ax, label='Wave Displacement \u03b7(x, y, t)') ax.set_title('Interference Pattern from 4 Coherent Wave Sources') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') # \ud83d\udd01 Animation update function def update(frame): t = frame * 0.1 eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) eta_total += eta c.set_array(eta_total.ravel()) return [c] # \u2699\ufe0f Create animation frames = 60 anim = FuncAnimation(fig, update, frames=frames, blit=True) # \ud83d\udcbe Save the animation as GIF gif_path = \"wave_interference.gif\" anim.save(gif_path, writer=PillowWriter(fps=10)) # \ud83c\udfac Display the gif from IPython.display import display display(Image(filename=gif_path)) \ud83d\udcda Wave Interference Simulation \u2013 Superposition of Multiple Sources \ud83e\udded Objective We simulate the interference pattern generated by multiple coherent point wave sources using the principle of wave superposition on a 2D water surface. \ud83e\uddee Step-by-Step Mathematical Procedure \ud83d\udd39 Step 1: Distance from Each Source to Grid Points To compute the contribution of each wave source at each grid point \\((x, y)\\) , we calculate the distance from the \\(i\\) -th source \\((x_i, y_i)\\) : \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] This quantity determines the phase and amplitude attenuation for each wave at a given point. \ud83d\udd39 Step 2: Superposition of Waves For each point on the grid, the total displacement is given by the principle of linear superposition : \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Each \\(\\eta_i\\) is the displacement from the \\(i\\) -th point source: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(kr_i - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude of the wave, - \\(r_i\\) is the distance to the \\(i\\) -th source, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the initial phase. \ud83e\uddea Simulation Implementation # \ud83d\udce6 Import libraries import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \ud83d\udcd0 Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase \u03c6 omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength # \ud83d\uddfa\ufe0f Spatial grid L = 5 # Domain size res = 400 # Resolution x = np.linspace(-L, L, res) y = np.linspace(-L, L, res) X, Y = np.meshgrid(x, y) t = 0.0 # Time snapshot # \ud83e\uddee Helper function to compute total wave displacement def compute_eta(sources): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) eta_total += eta return eta_total # \ud83d\udccd Define source configurations R = 2.0 # Radius for source placement # 1 Source (centered) sources_1 = [(0, 0)] # 4 Sources (square vertices) sources_4 = [ ( R, R), (-R, R), (-R, -R), ( R, -R) ] # 5 Sources (regular pentagon) sources_5 = [(R * np.cos(2*np.pi*i/5), R * np.sin(2*np.pi*i/5)) for i in range(5)] # \ud83d\udcca Generate all displacements eta_1 = compute_eta(sources_1) eta_4 = compute_eta(sources_4) eta_5 = compute_eta(sources_5) # \ud83c\udfa8 2D Heatmap Plot Function def plot_heatmap(eta, title): plt.figure(figsize=(6, 5)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='seismic') plt.colorbar(label='Wave Displacement \u03b7(x, y, t)') plt.title(title) plt.xlabel('x') plt.ylabel('y') plt.gca().set_aspect('equal') plt.tight_layout() plt.show() # \ud83c\udfd4\ufe0f 3D Surface Plot Function def plot_surface(eta, title): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(X, Y, eta, cmap='seismic', linewidth=0, antialiased=True) ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('\u03b7(x, y, t)') fig.colorbar(surf, shrink=0.5, aspect=10) plt.tight_layout() plt.show() # \ud83d\udccc Plot all 2D heatmaps plot_heatmap(eta_1, \"Heatmap: 1 Point Source\") plot_heatmap(eta_4, \"Heatmap: 4 Point Sources (Square)\") plot_heatmap(eta_5, \"Heatmap: 5 Point Sources (Pentagon)\") # \ud83d\udccc Plot all 3D surface plots plot_surface(eta_1, \"3D Surface: 1 Point Source\") plot_surface(eta_4, \"3D Surface: 4 Point Sources (Square)\") plot_surface(eta_5, \"3D Surface: 5 Point Sources (Pentagon)\")","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface-wave-modeling","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface \u2013 Wave Modeling"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-choosing-a-regular-polygon","text":"We begin by choosing a regular polygon as the geometric base for placing wave sources. In this case, we select a: Square : A 4-sided regular polygon. Let the side length be normalized, and the center of the square be located at the origin \\((0,0)\\) . Then, the vertices (wave sources) are placed symmetrically around the origin:","title":"\ud83d\udd37 Step 1: Choosing a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#vertex-coordinates-wave-sources","text":"Let the distance from the center to each vertex be \\(R\\) . Then the coordinates are: \\((x_1,y_1) = (R,R)\\) \\((x_2,y_2) = (-R,R)\\) \\((x_3,y_3) = (-R,-R)\\) \\((x_4,y_4) = (R,-R)\\) These correspond to the corners of a square centered at the origin.","title":"\ud83d\udd39 Vertex Coordinates (Wave Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-define-wave-parameters","text":"We define the physical properties of each wave emitted from the sources: Amplitude : \\(A\\) Wavelength : \\(\\lambda\\) Frequency : \\(f\\) Angular Frequency : $$ \\omega = 2\\pi f $$ Wave Number : $$ k = \\frac{2\\pi}{\\lambda} $$ Initial Phase : \\(\\phi\\) (Assume same phase for all sources for coherence)","title":"\ud83d\udcd0 Step 2: Define Wave Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-mathematical-model-single-source","text":"The displacement of the water surface at point \\((x,y)\\) and time \\(t\\) from a single point source located at \\((x_0,y_0)\\) is given by: \\[ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) , \\(A\\) is the amplitude, \\(k\\) is the wave number, \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase.","title":"\ud83e\uddee Step 3: Mathematical Model \u2013 Single Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-superposition-from-multiple-sources","text":"Since the waves from all sources are coherent and identical (same \\(A\\) , \\(k\\) , \\(f\\) , and \\(\\phi\\) ), the total surface displacement at any point \\((x,y)\\) and time \\(t\\) is: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} \\eta_i(x,y,t) \\] For a square, \\(N=4\\) , so: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{4} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos\\left(k r_i - \\omega t + \\phi\\right) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) for each source \\(i\\) .","title":"\ud83d\udcca Step 4: Superposition from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-codes","text":"# \ud83d\udce6 Import required libraries import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image # \ud83d\udcd0 Define wave and simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength # \ud83c\udfaf Define source positions (Square centered at origin, side length 2R) R = 2.0 sources = [ ( R, R), # top-right (-R, R), # top-left (-R, -R), # bottom-left ( R, -R), # bottom-right ] # \ud83d\uddfa\ufe0f Set up spatial grid x = np.linspace(-5, 5, 300) y = np.linspace(-5, 5, 300) X, Y = np.meshgrid(x, y) # \ud83c\udf9e\ufe0f Set up the figure fig, ax = plt.subplots(figsize=(6, 5)) c = ax.pcolormesh(X, Y, np.zeros_like(X), shading='auto', cmap='viridis', vmin=-2, vmax=2) fig.colorbar(c, ax=ax, label='Wave Displacement \u03b7(x, y, t)') ax.set_title('Interference Pattern from 4 Coherent Wave Sources') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') # \ud83d\udd01 Animation update function def update(frame): t = frame * 0.1 eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) eta_total += eta c.set_array(eta_total.ravel()) return [c] # \u2699\ufe0f Create animation frames = 60 anim = FuncAnimation(fig, update, frames=frames, blit=True) # \ud83d\udcbe Save the animation as GIF gif_path = \"wave_interference.gif\" anim.save(gif_path, writer=PillowWriter(fps=10)) # \ud83c\udfac Display the gif from IPython.display import display display(Image(filename=gif_path))","title":"Python codes"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-simulation-superposition-of-multiple-sources","text":"","title":"\ud83d\udcda Wave Interference Simulation \u2013 Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#objective","text":"We simulate the interference pattern generated by multiple coherent point wave sources using the principle of wave superposition on a 2D water surface.","title":"\ud83e\udded Objective"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-mathematical-procedure","text":"","title":"\ud83e\uddee Step-by-Step Mathematical Procedure"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-distance-from-each-source-to-grid-points","text":"To compute the contribution of each wave source at each grid point \\((x, y)\\) , we calculate the distance from the \\(i\\) -th source \\((x_i, y_i)\\) : \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] This quantity determines the phase and amplitude attenuation for each wave at a given point.","title":"\ud83d\udd39 Step 1: Distance from Each Source to Grid Points"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-superposition-of-waves","text":"For each point on the grid, the total displacement is given by the principle of linear superposition : \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Each \\(\\eta_i\\) is the displacement from the \\(i\\) -th point source: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(kr_i - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude of the wave, - \\(r_i\\) is the distance to the \\(i\\) -th source, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the initial phase.","title":"\ud83d\udd39 Step 2: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-implementation","text":"# \ud83d\udce6 Import libraries import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \ud83d\udcd0 Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase \u03c6 omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength # \ud83d\uddfa\ufe0f Spatial grid L = 5 # Domain size res = 400 # Resolution x = np.linspace(-L, L, res) y = np.linspace(-L, L, res) X, Y = np.meshgrid(x, y) t = 0.0 # Time snapshot # \ud83e\uddee Helper function to compute total wave displacement def compute_eta(sources): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) eta_total += eta return eta_total # \ud83d\udccd Define source configurations R = 2.0 # Radius for source placement # 1 Source (centered) sources_1 = [(0, 0)] # 4 Sources (square vertices) sources_4 = [ ( R, R), (-R, R), (-R, -R), ( R, -R) ] # 5 Sources (regular pentagon) sources_5 = [(R * np.cos(2*np.pi*i/5), R * np.sin(2*np.pi*i/5)) for i in range(5)] # \ud83d\udcca Generate all displacements eta_1 = compute_eta(sources_1) eta_4 = compute_eta(sources_4) eta_5 = compute_eta(sources_5) # \ud83c\udfa8 2D Heatmap Plot Function def plot_heatmap(eta, title): plt.figure(figsize=(6, 5)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='seismic') plt.colorbar(label='Wave Displacement \u03b7(x, y, t)') plt.title(title) plt.xlabel('x') plt.ylabel('y') plt.gca().set_aspect('equal') plt.tight_layout() plt.show() # \ud83c\udfd4\ufe0f 3D Surface Plot Function def plot_surface(eta, title): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(X, Y, eta, cmap='seismic', linewidth=0, antialiased=True) ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('\u03b7(x, y, t)') fig.colorbar(surf, shrink=0.5, aspect=10) plt.tight_layout() plt.show() # \ud83d\udccc Plot all 2D heatmaps plot_heatmap(eta_1, \"Heatmap: 1 Point Source\") plot_heatmap(eta_4, \"Heatmap: 4 Point Sources (Square)\") plot_heatmap(eta_5, \"Heatmap: 5 Point Sources (Pentagon)\") # \ud83d\udccc Plot all 3D surface plots plot_surface(eta_1, \"3D Surface: 1 Point Source\") plot_surface(eta_4, \"3D Surface: 4 Point Sources (Square)\") plot_surface(eta_5, \"3D Surface: 5 Point Sources (Pentagon)\")","title":"\ud83e\uddea Simulation Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism: Lorentz Force Simulation \ud83e\udded 1. Explore Applications of the Lorentz Force The Lorentz Force governs the motion of charged particles in electromagnetic fields and is given by: \\[\\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}\\] Where: \\(\\mathbf{F}\\) : Force on the particle (N) \\(q\\) : Charge of the particle (C) \\(\\mathbf{E}\\) : Electric field vector (V/m) \\(\\mathbf{v}\\) : Velocity of the particle (m/s) \\(\\mathbf{B}\\) : Magnetic field vector (T) \ud83d\udd2c Real-World Systems Where Lorentz Force is Crucial Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers (for charge-to-mass ratio analysis) Plasma Confinement (in fusion devices like Tokamaks) Cathode Ray Tubes (e.g., in old TV displays) Cosmic Ray Deflection (motion of particles in Earth's magnetic field) \ud83c\udfaf Roles of Electric and Magnetic Fields Electric Field ( \\(\\mathbf{E}\\) ) : Exerts a force in the direction of the field . Accelerates particles linearly. Magnetic Field ( \\(\\mathbf{B}\\) ) : Exerts a force perpendicular to both \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) . Does no work on the particle (changes direction, not speed). Causes circular or helical motion . \ud83e\uddea 2. Simulating Particle Motion Under Lorentz Force We solve Newton's second law using: \\[m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] Numerical integration is used to compute the particle\u2019s trajectory over time. \ud83d\udd04 Motion Types Observed Circular Motion : If \\(\\mathbf{v} \\perp \\mathbf{B}\\) , and \\(\\mathbf{E} = 0\\) . Helical Motion : If \\(\\mathbf{v}\\) has a component along \\(\\mathbf{B}\\) . Drift Motion : When both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) are present and crossed, the particle drifts with: \\[\\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\] \ud83d\udcca 3D Trajectory Visualization # \u2705 Import libraries import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ========================== 1. Circular Motion (2D Gradient) ========================== t1 = np.linspace(0, 10, 500) r = 1 x1 = r * np.cos(t1) y1 = r * np.sin(t1) plt.figure(figsize=(7,6)) plt.title('1\ufe0f\u20e3 Circular Motion (Plasma Gradient)', fontsize=14, weight='bold') scatter1 = plt.scatter(x1, y1, c=t1, cmap='plasma', s=5) plt.plot(x1, y1, alpha=0.2, color='gray') plt.plot(x1[0], y1[0], 'go', label='Start') plt.plot(x1[-1], y1[-1], 'ro', label='End') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.colorbar(scatter1, label='Time (s)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # ========================== 2. Helical Motion (3D Gradient) ========================== t2 = np.linspace(0, 10, 500) x2 = np.cos(t2) y2 = np.sin(t2) z2 = t2**1.2 fig = plt.figure(figsize=(8,6)) ax2 = fig.add_subplot(111, projection='3d') ax2.set_title('2\ufe0f\u20e3 Helical Motion (Cividis Gradient)', fontsize=14, weight='bold') scatter2 = ax2.scatter(x2, y2, z2, c=t2, cmap='cividis', s=5) ax2.plot(x2, y2, z2, color='gray', alpha=0.2) ax2.scatter(x2[0], y2[0], z2[0], color='lime', s=40, label='Start') ax2.scatter(x2[-1], y2[-1], z2[-1], color='red', s=40, label='End') ax2.set_xlabel('x (m)') ax2.set_ylabel('y (m)') ax2.set_zlabel('z (m)') fig.colorbar(scatter2, ax=ax2, label='Time (s)') ax2.legend() plt.tight_layout() plt.show() # ========================== 3. Drift Motion (E x B Drift) ========================== t3 = np.linspace(0, 10 * np.pi, 1000) x3 = t3 / 10 y3 = np.sin(t3) z3 = np.zeros_like(t3) fig = plt.figure(figsize=(8,6)) ax3 = fig.add_subplot(111, projection='3d') ax3.set_title('3\ufe0f\u20e3 E \u00d7 B Drift Motion (Orange Line)', fontsize=14, weight='bold') ax3.plot(x3, y3, z3, color='orange', linewidth=2, label='Drift Path') ax3.scatter(x3[0], y3[0], z3[0], color='lime', s=40, label='Start') ax3.scatter(x3[-1], y3[-1], z3[-1], color='red', s=40, label='End') ax3.set_xlabel('x (m)') ax3.set_ylabel('y (m)') ax3.set_zlabel('z (m)') ax3.legend() plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"\u26a1 Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-explore-applications-of-the-lorentz-force","text":"The Lorentz Force governs the motion of charged particles in electromagnetic fields and is given by: \\[\\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}\\] Where: \\(\\mathbf{F}\\) : Force on the particle (N) \\(q\\) : Charge of the particle (C) \\(\\mathbf{E}\\) : Electric field vector (V/m) \\(\\mathbf{v}\\) : Velocity of the particle (m/s) \\(\\mathbf{B}\\) : Magnetic field vector (T)","title":"\ud83e\udded 1. Explore Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-systems-where-lorentz-force-is-crucial","text":"Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers (for charge-to-mass ratio analysis) Plasma Confinement (in fusion devices like Tokamaks) Cathode Ray Tubes (e.g., in old TV displays) Cosmic Ray Deflection (motion of particles in Earth's magnetic field)","title":"\ud83d\udd2c Real-World Systems Where Lorentz Force is Crucial"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#roles-of-electric-and-magnetic-fields","text":"Electric Field ( \\(\\mathbf{E}\\) ) : Exerts a force in the direction of the field . Accelerates particles linearly. Magnetic Field ( \\(\\mathbf{B}\\) ) : Exerts a force perpendicular to both \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) . Does no work on the particle (changes direction, not speed). Causes circular or helical motion .","title":"\ud83c\udfaf Roles of Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion-under-lorentz-force","text":"We solve Newton's second law using: \\[m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] Numerical integration is used to compute the particle\u2019s trajectory over time.","title":"\ud83e\uddea 2. Simulating Particle Motion Under Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motion-types-observed","text":"Circular Motion : If \\(\\mathbf{v} \\perp \\mathbf{B}\\) , and \\(\\mathbf{E} = 0\\) . Helical Motion : If \\(\\mathbf{v}\\) has a component along \\(\\mathbf{B}\\) . Drift Motion : When both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) are present and crossed, the particle drifts with: \\[\\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\]","title":"\ud83d\udd04 Motion Types Observed"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3d-trajectory-visualization","text":"# \u2705 Import libraries import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ========================== 1. Circular Motion (2D Gradient) ========================== t1 = np.linspace(0, 10, 500) r = 1 x1 = r * np.cos(t1) y1 = r * np.sin(t1) plt.figure(figsize=(7,6)) plt.title('1\ufe0f\u20e3 Circular Motion (Plasma Gradient)', fontsize=14, weight='bold') scatter1 = plt.scatter(x1, y1, c=t1, cmap='plasma', s=5) plt.plot(x1, y1, alpha=0.2, color='gray') plt.plot(x1[0], y1[0], 'go', label='Start') plt.plot(x1[-1], y1[-1], 'ro', label='End') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.colorbar(scatter1, label='Time (s)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # ========================== 2. Helical Motion (3D Gradient) ========================== t2 = np.linspace(0, 10, 500) x2 = np.cos(t2) y2 = np.sin(t2) z2 = t2**1.2 fig = plt.figure(figsize=(8,6)) ax2 = fig.add_subplot(111, projection='3d') ax2.set_title('2\ufe0f\u20e3 Helical Motion (Cividis Gradient)', fontsize=14, weight='bold') scatter2 = ax2.scatter(x2, y2, z2, c=t2, cmap='cividis', s=5) ax2.plot(x2, y2, z2, color='gray', alpha=0.2) ax2.scatter(x2[0], y2[0], z2[0], color='lime', s=40, label='Start') ax2.scatter(x2[-1], y2[-1], z2[-1], color='red', s=40, label='End') ax2.set_xlabel('x (m)') ax2.set_ylabel('y (m)') ax2.set_zlabel('z (m)') fig.colorbar(scatter2, ax=ax2, label='Time (s)') ax2.legend() plt.tight_layout() plt.show() # ========================== 3. Drift Motion (E x B Drift) ========================== t3 = np.linspace(0, 10 * np.pi, 1000) x3 = t3 / 10 y3 = np.sin(t3) z3 = np.zeros_like(t3) fig = plt.figure(figsize=(8,6)) ax3 = fig.add_subplot(111, projection='3d') ax3.set_title('3\ufe0f\u20e3 E \u00d7 B Drift Motion (Orange Line)', fontsize=14, weight='bold') ax3.plot(x3, y3, z3, color='orange', linewidth=2, label='Drift Path') ax3.scatter(x3[0], y3[0], z3[0], color='lime', s=40, label='Start') ax3.scatter(x3[-1], y3[-1], z3[-1], color='red', s=40, label='End') ax3.set_xlabel('x (m)') ax3.set_ylabel('y (m)') ax3.set_zlabel('z (m)') ax3.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcca 3D Trajectory Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"q# Problem 1 Exploring the Central Limit Theorem through Simulation Project objective: Build intuitive understanding of the Central Limit Theorem (CLT) by simulating sampling distributions of the sample mean for several population distributions. 1 Mathematical Background Population mean : \\( \\(\\mu=\\mathbb{E}[X]\\) \\) Sample mean (for a sample of size \\(n\\) ): \\( \\(\\bar{X}_n=\\frac{1}{n}\\sum_{i=1}^{n}X_i\\) \\) Central Limit Theorem (one-dimensional form) : \\( \\(\\boxed{\\sqrt{n}\\,\\frac{\\bar{X}_n-\\mu}{\\sigma}\\;\\xrightarrow{\\;d\\;}\\;\\mathcal{N}(0,1)}\\) \\) where \\(\\sigma^2=\\operatorname{Var}(X)\\) and \\(\\xrightarrow{\\;d\\;}\\) denotes convergence in distribution. Regardless of the parent distribution , the standardized sample mean approaches the standard normal distribution as \\(n\\to\\infty\\) . 2 Project Road-Map Set up population distributions \u2022 Uniform( \\(a,b\\) ) \u2022 Exponential( \\(\\lambda\\) ) \u2022 Binomial( \\(N,p\\) ) Generate a large synthetic population for each. Sampling & sample-mean computation \u2022 Pick sample sizes \\(n\\in\\{5,10,30,50\\}\\) . \u2022 For each distribution & \\(n\\) : \u2013 Draw \\(M\\) independent samples (e.g. \\(M=10,000\\) ). \u2013 Compute \\(\\bar{X}_n\\) for every draw. \u2013 Store the vector of means \u2192 sampling distribution . (Next) Visualisation & diagnostics (placeholder) \u2022 Histograms & KDEs of sampling distributions. \u2022 Normal Q\u2013Q plots & Shapiro\u2013Wilk tests. 3 Python Implementation # \ud83d\udce6 Imports import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # \ud83c\udfb2 Reproducibility rng = np.random.default_rng(seed=42) # \ud83d\udd27 Simulation parameters POP_SIZE = 1_000_000 M = 10_000 SAMPLE_SIZES = [5, 10, 30, 50] # \ud83d\udcca Create populations a, b = 0, 1 pop_uniform = rng.uniform(a, b, POP_SIZE) lambd = 1.0 pop_expon = rng.exponential(1 / lambd, POP_SIZE) N, p = 10, 0.3 pop_binom = rng.binomial(N, p, POP_SIZE) populations = { 'Uniform(0,1)': pop_uniform, 'Exponential(\u03bb=1)': pop_expon, 'Binomial(N=10, p=0.3)': pop_binom, } # \ud83e\uddee Helper to draw sample means def sample_means(pop, n, m=M): idx = rng.integers(0, len(pop), size=m * n) samples = pop[idx].reshape(m, n) return samples.mean(axis=1) # \ud83d\udce6 Generate sampling distributions sampling_distributions = {} for name, pop in populations.items(): sampling_distributions[name] = {} for n in SAMPLE_SIZES: sampling_distributions[name][n] = sample_means(pop, n) # \ud83d\udcca Plotting function def plot_sampling_distributions(sampling_distributions, populations): sns.set(style='whitegrid', palette='muted') fig, axs = plt.subplots( nrows=3, ncols=4, figsize=(20, 12), constrained_layout=True ) for row_idx, (dist_name, n_dict) in enumerate(sampling_distributions.items()): pop_data = populations[dist_name] mu = np.mean(pop_data) sigma = np.std(pop_data) for col_idx, n in enumerate(SAMPLE_SIZES): ax = axs[row_idx, col_idx] sample_means = n_dict[n] sns.histplot(sample_means, bins=50, stat='density', kde=False, ax=ax, color='skyblue', edgecolor='black', label='Sample Means') # Overlay Normal distribution x = np.linspace(sample_means.min(), sample_means.max(), 200) pdf = norm.pdf(x, loc=mu, scale=sigma / np.sqrt(n)) ax.plot(x, pdf, 'r--', lw=2, label='Normal PDF') ax.set_title(f'{dist_name}, n={n}', fontsize=11) ax.set_xlabel('Sample Mean') ax.set_ylabel('Density') if col_idx == 0: ax.legend() fig.suptitle('Central Limit Theorem: Sampling Distributions of the Mean', fontsize=16) plt.show() # \ud83d\udd0d Display visualisation plot_sampling_distributions(sampling_distributions, populations) 4 Next Steps Visualise each means array with histograms & overlay a normal PDF. Standardise the sample means: \\( \\(Z=\\sqrt{n}\\,\\frac{\\bar{X}_n-\\mu}{\\sigma}\\) \\) Plot their distribution and compare to \\(\\mathcal{N}(0,1)\\) . Formal tests : Kolmogorov\u2013Smirnov or Anderson\u2013Darling goodness-of-fit. Feel free to extend or refactor the code \u2013 this notebook is meant as a clean, well-commented starting point. Citation reminder: If you use these materials in an academic context, please credit the author(s) appropriately. \ud83d\udcca Visualizing and Understanding the Central Limit Theorem (CLT) \ud83c\udfaf Objective Explore how sampling distributions evolve as sample size increases, and reflect on the broader importance of the Central Limit Theorem (CLT) in statistics and real-world applications. \ud83d\udd0d 4. Visualize Sampling Distributions \ud83d\udccc Goal: To observe how sample means behave when drawn from different population distributions with varying sample sizes. \ud83d\udcc8 Approach: For each population distribution: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(N = 10, p = 0.3) For each sample size \\(n \\in \\{5, 10, 30, 50\\}\\) : Draw \\(M = 10{,}000\\) random samples Compute the sample mean \\(\\bar{X}_n\\) Plot a histogram of the resulting sample means \ud83e\udde0 Observation Focus: Does the shape of the sampling distribution look approximately normal? How does the shape change as \\(n\\) increases? \ud83d\udcd0 Theoretical Foundation: Let \\(X_1, X_2, \\dots, X_n\\) be i.i.d. random variables from a population with: - Mean \\(\\mu\\) - Variance \\(\\sigma^2\\) Then the sample mean is: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i \\] According to the Central Limit Theorem : \\[ \\sqrt{n} \\cdot \\frac{\\bar{X}_n - \\mu}{\\sigma} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] As \\(n \\to \\infty\\) , the sampling distribution of \\(\\bar{X}_n\\) approaches a normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) . \ud83d\udd2c 5. Analyze and Explore Parameters \u2753 Questions to Investigate: How quickly do the sampling distributions become approximately normal for each population? How does sample size influence the spread and shape of the distribution? What is the role of population variance \\(\\sigma^2\\) on the width of the sampling distribution? \ud83d\udccf Key Relationships: Spread of the sampling distribution : \\[ \\operatorname{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} \\] So, larger \\(n\\) leads to narrower (more concentrated) distributions of \\(\\bar{X}_n\\) . Skewness and Convergence : Highly skewed populations (like Exponential) require larger \\(n\\) to exhibit normality in \\(\\bar{X}_n\\) Symmetric distributions (like Uniform) converge to normal shape more quickly \ud83c\udf0d 6. Reflect on Real-World Applications The Central Limit Theorem is essential in many fields: \ud83e\uddea 1. Estimating Unknown Parameters Enables confidence intervals and hypothesis tests using sample statistics Even if population is non-normal, \\(\\bar{X}_n\\) is approximately normal for large \\(n\\) \ud83c\udfed 2. Manufacturing Quality Control Sampling the number of defective products from a batch Use sample means to detect deviations from target quality \ud83d\udcb9 3. Financial Modeling Average returns over time intervals Risk assessment using aggregated asset behavior \ud83d\udcda Conclusion : The CLT provides a powerful theoretical foundation that justifies using normal models in real-world data analysis. It assures us that sample averages behave predictably even when individual data points do not.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulation","text":"Project objective: Build intuitive understanding of the Central Limit Theorem (CLT) by simulating sampling distributions of the sample mean for several population distributions.","title":"Exploring the Central Limit Theorem through Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-mathematical-background","text":"Population mean : \\( \\(\\mu=\\mathbb{E}[X]\\) \\) Sample mean (for a sample of size \\(n\\) ): \\( \\(\\bar{X}_n=\\frac{1}{n}\\sum_{i=1}^{n}X_i\\) \\) Central Limit Theorem (one-dimensional form) : \\( \\(\\boxed{\\sqrt{n}\\,\\frac{\\bar{X}_n-\\mu}{\\sigma}\\;\\xrightarrow{\\;d\\;}\\;\\mathcal{N}(0,1)}\\) \\) where \\(\\sigma^2=\\operatorname{Var}(X)\\) and \\(\\xrightarrow{\\;d\\;}\\) denotes convergence in distribution. Regardless of the parent distribution , the standardized sample mean approaches the standard normal distribution as \\(n\\to\\infty\\) .","title":"1 Mathematical Background"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-project-road-map","text":"Set up population distributions \u2022 Uniform( \\(a,b\\) ) \u2022 Exponential( \\(\\lambda\\) ) \u2022 Binomial( \\(N,p\\) ) Generate a large synthetic population for each. Sampling & sample-mean computation \u2022 Pick sample sizes \\(n\\in\\{5,10,30,50\\}\\) . \u2022 For each distribution & \\(n\\) : \u2013 Draw \\(M\\) independent samples (e.g. \\(M=10,000\\) ). \u2013 Compute \\(\\bar{X}_n\\) for every draw. \u2013 Store the vector of means \u2192 sampling distribution . (Next) Visualisation & diagnostics (placeholder) \u2022 Histograms & KDEs of sampling distributions. \u2022 Normal Q\u2013Q plots & Shapiro\u2013Wilk tests.","title":"2 Project Road-Map"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-python-implementation","text":"# \ud83d\udce6 Imports import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # \ud83c\udfb2 Reproducibility rng = np.random.default_rng(seed=42) # \ud83d\udd27 Simulation parameters POP_SIZE = 1_000_000 M = 10_000 SAMPLE_SIZES = [5, 10, 30, 50] # \ud83d\udcca Create populations a, b = 0, 1 pop_uniform = rng.uniform(a, b, POP_SIZE) lambd = 1.0 pop_expon = rng.exponential(1 / lambd, POP_SIZE) N, p = 10, 0.3 pop_binom = rng.binomial(N, p, POP_SIZE) populations = { 'Uniform(0,1)': pop_uniform, 'Exponential(\u03bb=1)': pop_expon, 'Binomial(N=10, p=0.3)': pop_binom, } # \ud83e\uddee Helper to draw sample means def sample_means(pop, n, m=M): idx = rng.integers(0, len(pop), size=m * n) samples = pop[idx].reshape(m, n) return samples.mean(axis=1) # \ud83d\udce6 Generate sampling distributions sampling_distributions = {} for name, pop in populations.items(): sampling_distributions[name] = {} for n in SAMPLE_SIZES: sampling_distributions[name][n] = sample_means(pop, n) # \ud83d\udcca Plotting function def plot_sampling_distributions(sampling_distributions, populations): sns.set(style='whitegrid', palette='muted') fig, axs = plt.subplots( nrows=3, ncols=4, figsize=(20, 12), constrained_layout=True ) for row_idx, (dist_name, n_dict) in enumerate(sampling_distributions.items()): pop_data = populations[dist_name] mu = np.mean(pop_data) sigma = np.std(pop_data) for col_idx, n in enumerate(SAMPLE_SIZES): ax = axs[row_idx, col_idx] sample_means = n_dict[n] sns.histplot(sample_means, bins=50, stat='density', kde=False, ax=ax, color='skyblue', edgecolor='black', label='Sample Means') # Overlay Normal distribution x = np.linspace(sample_means.min(), sample_means.max(), 200) pdf = norm.pdf(x, loc=mu, scale=sigma / np.sqrt(n)) ax.plot(x, pdf, 'r--', lw=2, label='Normal PDF') ax.set_title(f'{dist_name}, n={n}', fontsize=11) ax.set_xlabel('Sample Mean') ax.set_ylabel('Density') if col_idx == 0: ax.legend() fig.suptitle('Central Limit Theorem: Sampling Distributions of the Mean', fontsize=16) plt.show() # \ud83d\udd0d Display visualisation plot_sampling_distributions(sampling_distributions, populations)","title":"3 Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-next-steps","text":"Visualise each means array with histograms & overlay a normal PDF. Standardise the sample means: \\( \\(Z=\\sqrt{n}\\,\\frac{\\bar{X}_n-\\mu}{\\sigma}\\) \\) Plot their distribution and compare to \\(\\mathcal{N}(0,1)\\) . Formal tests : Kolmogorov\u2013Smirnov or Anderson\u2013Darling goodness-of-fit. Feel free to extend or refactor the code \u2013 this notebook is meant as a clean, well-commented starting point. Citation reminder: If you use these materials in an academic context, please credit the author(s) appropriately.","title":"4 Next Steps"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualizing-and-understanding-the-central-limit-theorem-clt","text":"","title":"\ud83d\udcca Visualizing and Understanding the Central Limit Theorem (CLT)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Explore how sampling distributions evolve as sample size increases, and reflect on the broader importance of the Central Limit Theorem (CLT) in statistics and real-world applications.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-visualize-sampling-distributions","text":"","title":"\ud83d\udd0d 4. Visualize Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#goal","text":"To observe how sample means behave when drawn from different population distributions with varying sample sizes.","title":"\ud83d\udccc Goal:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#approach","text":"For each population distribution: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(N = 10, p = 0.3) For each sample size \\(n \\in \\{5, 10, 30, 50\\}\\) : Draw \\(M = 10{,}000\\) random samples Compute the sample mean \\(\\bar{X}_n\\) Plot a histogram of the resulting sample means","title":"\ud83d\udcc8 Approach:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observation-focus","text":"Does the shape of the sampling distribution look approximately normal? How does the shape change as \\(n\\) increases?","title":"\ud83e\udde0 Observation Focus:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theoretical-foundation","text":"Let \\(X_1, X_2, \\dots, X_n\\) be i.i.d. random variables from a population with: - Mean \\(\\mu\\) - Variance \\(\\sigma^2\\) Then the sample mean is: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i \\] According to the Central Limit Theorem : \\[ \\sqrt{n} \\cdot \\frac{\\bar{X}_n - \\mu}{\\sigma} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] As \\(n \\to \\infty\\) , the sampling distribution of \\(\\bar{X}_n\\) approaches a normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) .","title":"\ud83d\udcd0 Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-analyze-and-explore-parameters","text":"","title":"\ud83d\udd2c 5. Analyze and Explore Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#questions-to-investigate","text":"How quickly do the sampling distributions become approximately normal for each population? How does sample size influence the spread and shape of the distribution? What is the role of population variance \\(\\sigma^2\\) on the width of the sampling distribution?","title":"\u2753 Questions to Investigate:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-relationships","text":"Spread of the sampling distribution : \\[ \\operatorname{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} \\] So, larger \\(n\\) leads to narrower (more concentrated) distributions of \\(\\bar{X}_n\\) . Skewness and Convergence : Highly skewed populations (like Exponential) require larger \\(n\\) to exhibit normality in \\(\\bar{X}_n\\) Symmetric distributions (like Uniform) converge to normal shape more quickly","title":"\ud83d\udccf Key Relationships:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-reflect-on-real-world-applications","text":"The Central Limit Theorem is essential in many fields:","title":"\ud83c\udf0d 6. Reflect on Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-estimating-unknown-parameters","text":"Enables confidence intervals and hypothesis tests using sample statistics Even if population is non-normal, \\(\\bar{X}_n\\) is approximately normal for large \\(n\\)","title":"\ud83e\uddea 1. Estimating Unknown Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-manufacturing-quality-control","text":"Sampling the number of defective products from a batch Use sample means to detect deviations from target quality","title":"\ud83c\udfed 2. Manufacturing Quality Control"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-financial-modeling","text":"Average returns over time intervals Risk assessment using aggregated asset behavior \ud83d\udcda Conclusion : The CLT provides a powerful theoretical foundation that justifies using normal models in real-world data analysis. It assures us that sample averages behave predictably even when individual data points do not.","title":"\ud83d\udcb9 3. Financial Modeling"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83e\udde0 Estimating \u03c0 Using Monte Carlo Simulation (Circle Method) 1. \ud83c\udf93 Theoretical Foundation Monte Carlo methods estimate values using random sampling and probabilistic principles. In this method, we use a unit circle inscribed in a square to estimate the value of \u03c0. \ud83d\udd37 Geometric Principle Consider a unit circle of radius 1 centered at the origin. Enclose it in a square with side length 2 (ranging from -1 to 1 on both x and y axes). Generate random points \\((x, y)\\) uniformly inside the square. Count how many points fall inside the circle using the condition: \\[ x^2 + y^2 \\leq 1 \\] The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2r)^2 = 4 \\] The ratio of the areas gives the probability that a random point falls inside the circle: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Solving for \u03c0: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points inside circle}}{\\text{Total points}} \\] 2. \ud83e\uddea Simulation Below is the Python code to implement this method and estimate the value of \u03c0. import numpy as np import matplotlib.pyplot as plt # Number of random points N = 10000 # Generate N random points in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Compute distance from origin for each point distance_squared = x**2 + y**2 # Count how many points fall inside the unit circle inside_circle = distance_squared <= 1 count_inside = np.sum(inside_circle) # Estimate \u03c0 pi_estimate = 4 * count_inside / N print(f\"Estimated \u03c0 \u2248 {pi_estimate}\") # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) plt.gca().add_patch(circle) plt.axhline(0, color='gray', linestyle='--') plt.axvline(0, color='gray', linestyle='--') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (N={N})\") plt.legend() plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image, display # Generate N random points N = 1000 step = 10 # number of points added per frame x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) distance_squared = x**2 + y**2 inside_circle = distance_squared <= 1 # Setup figure fig, ax = plt.subplots(figsize=(6, 6)) sc_inside = ax.scatter([], [], color='deepskyblue', s=6, alpha=0.7, label='Inside Circle') sc_outside = ax.scatter([], [], color='crimson', s=6, alpha=0.7, label='Outside Circle') # Add unit circle circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) ax.add_patch(circle) # Format plot ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_aspect('equal') ax.set_xlabel(\"x\", fontsize=12) ax.set_ylabel(\"y\", fontsize=12) ax.set_title(\"Monte Carlo Estimation of \u03c0\", fontsize=14) ax.legend(loc='upper right', fontsize=10) ax.grid(True) # Update function for animation def update(frame): idx = (frame + 1) * step x_in = x[inside_circle][:idx] y_in = y[inside_circle][:idx] x_out = x[~inside_circle][:idx] y_out = y[~inside_circle][:idx] sc_inside.set_offsets(np.column_stack((x_in, y_in))) sc_outside.set_offsets(np.column_stack((x_out, y_out))) total = len(x_in) + len(x_out) pi_estimate = 4 * len(x_in) / total if total > 0 else 0 ax.set_title(f\"Monte Carlo Estimation of \u03c0\\nPoints: {total}, \u03c0 \u2248 {pi_estimate:.5f}\", fontsize=14) # Create animation frames = N // step ani = FuncAnimation(fig, update, frames=frames, interval=50, repeat=False) # Save the animation as a GIF ani.save(\"monte_carlo_pi.gif\", writer=PillowWriter(fps=20)) # Display the GIF inline display(Image(filename=\"monte_carlo_pi.gif\")) \u2705 Summary We used uniform random sampling within a square to approximate the value of \u03c0. The ratio of points inside the circle to the total number gives us a way to estimate \u03c0 using: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points inside}}{\\text{Total points}} \\] Increasing the number of points improves the accuracy due to the law of large numbers . \ud83e\udde0 Theoretical Foundation: Buffon\u2019s Needle Problem \ud83d\udcd6 Problem Setup Buffon\u2019s Needle is a classic probability problem posed by Georges-Louis Leclerc, Comte de Buffon in the 18th century. It presents a simple yet profound way to estimate the value of \\(\\pi\\) using randomness and geometry. Imagine a plane with equally spaced parallel lines a distance \\(t\\) apart. A needle of length \\(L\\) (where \\(L \\leq t\\) ) is randomly dropped onto this plane. We repeat this process \\(N\\) times and observe how many times the needle crosses a line. This stochastic process can be used to estimate the value of \\(\\pi\\) based on the probability of a crossing . \ud83e\uddee Derivation of the Formula Let: - \\(L\\) = length of the needle - \\(t\\) = distance between lines (assume \\(L \\leq t\\) ) - \\(N\\) = number of needle drops - \\(C\\) = number of times the needle crosses a line The probability that a single needle will cross a line is given by: \\[ P = \\frac{2L}{t\\pi} \\] Hence, if we drop \\(N\\) needles and observe \\(C\\) crossings, we estimate \\(P \\approx \\frac{C}{N}\\) . Rearranging the equation to solve for \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} \\] \ud83d\udee0\ufe0f Simulation Steps To perform the Monte Carlo simulation of Buffon\u2019s Needle: Randomly drop \\(N\\) needles : For each needle, generate: A random distance from the center of the needle to the nearest line: $$ y \\in [0, t/2] $$ A random angle \\(\\theta\\) between the needle and the parallel lines: $$ \\theta \\in [0, \\pi/2] $$ Determine if a needle crosses a line : A needle crosses a line if the vertical projection from its center exceeds \\(y\\) , i.e.: $$ \\frac{L}{2} \\sin(\\theta) \\geq y $$ Count the number of crossings \\(C\\) . Estimate \\(\\pi\\) using the derived formula: $$ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} $$ \ud83d\udccc Important Notes For accurate results, ensure \\(L \\leq t\\) . The larger the number of trials \\(N\\) , the more accurate the approximation of \\(\\pi\\) becomes. Buffon's Needle illustrates the deep connection between geometry , probability , and mathematical constants like \\(\\pi\\) . \ud83c\udfa8 Visualization of Buffon's Needle Simulation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from matplotlib.animation import PillowWriter # Parameters L = 0.9 # Needle length t = 1.0 # Distance between lines N = 200 # Number of needle drops line_count = 10 # Number of parallel lines # Generate random needle centers and angles x_centers = np.random.uniform(0, line_count, N) y_centers = np.random.uniform(0, line_count, N) angles = np.random.uniform(0, np.pi, N) # Calculate needle endpoints dx = (L / 2) * np.cos(angles) dy = (L / 2) * np.sin(angles) x1 = x_centers - dx x2 = x_centers + dx y1 = y_centers - dy y2 = y_centers + dy # Determine crossings crossings = (np.floor(y1 / t) != np.floor(y2 / t)) # Set up figure and axes fig, ax = plt.subplots(figsize=(8, 8)) # Initialize plot def init(): ax.set_xlim(0, line_count) ax.set_ylim(0, line_count) ax.set_aspect('equal') ax.set_xlabel(\"x-position\") ax.set_ylabel(\"y-position\") ax.set_title(\"Buffon's Needle Simulation\\nGreen = Crosses Line, Red = Doesn't Cross\", fontsize=14) ax.grid(True) for i in range(line_count + 1): ax.axhline(i * t, color='gray', linestyle='--', linewidth=1) return [] # Update function for animation def update(frame): color = 'green' if crossings[frame] else 'red' ax.plot([x1[frame], x2[frame]], [y1[frame], y2[frame]], color=color, alpha=0.7) return [] # Create animation ani = animation.FuncAnimation(fig, update, frames=N, init_func=init, blit=False, interval=50, repeat=False) # Save as GIF gif_path = \"/content/buffon_simulation.gif\" ani.save(gif_path, writer=PillowWriter(fps=20)) print(\"GIF saved to:\", gif_path) \ud83d\uddbc\ufe0f Geometric Representation To visually understand how Buffon\u2019s Needle estimates \u03c0, we simulate and plot: Equally spaced parallel lines a distance \\(t\\) apart, running horizontally. Randomly dropped needles , each with: A center point \\((x, y)\\) within the simulation area. A random orientation angle \\(\\theta\\) . Two endpoints computed using: $$ \\text{end}_1 = \\left(x - \\frac{L}{2} \\cos\\theta,\\ y - \\frac{L}{2} \\sin\\theta\\right) $$ $$ \\text{end}_2 = \\left(x + \\frac{L}{2} \\cos\\theta,\\ y + \\frac{L}{2} \\sin\\theta\\right) $$ \ud83d\udd0d Visual Features Parallel lines : drawn as horizontal gray or black lines at \\(y = nt\\) for integer \\(n\\) . Needles that cross a line : Highlighted in green . Needles that do not cross : Shown in red or another contrasting color. Use alpha transparency and thin lines to reduce visual clutter. \ud83d\udcca Analysis of Estimation Accuracy \ud83d\udcc8 Effect of Number of Drops ( \\(N\\) ) As with many Monte Carlo methods, the accuracy of the \u03c0 estimate improves with more trials: For small \\(N\\) , the estimate fluctuates significantly due to randomness. For large \\(N\\) , the estimate converges slowly toward the true value of \\(\\pi\\) . The convergence is statistical and exhibits variance , roughly decreasing with: $$ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} $$ \ud83d\udd01 Comparison to Circle-Based Monte Carlo Feature Buffon\u2019s Needle Circle Method Geometry Lines and needles Square and inscribed circle \u03c0 Formula \\(\\pi \\approx \\frac{2L \\cdot N}{t \\cdot C}\\) \\(\\pi \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}}\\) Convergence Rate Slow Moderate Visual Intuition Strong Very strong Computational Simplicity Moderate High Accuracy (at same \\(N\\) ) Typically lower Typically higher \ud83d\udccc Recommendations Use Buffon\u2019s method to teach geometric probability . For practical Monte Carlo \u03c0 estimation, prefer the circle method for faster convergence and simpler implementation. Combine visual outputs with \u03c0 vs. \\(N\\) convergence plots for deeper insight. \ud83d\udcc9 Optional Extensions Plot a curve showing \\(\\pi\\) estimates as a function of \\(N\\) . Overlay a line showing the true value \\(\\pi \\approx 3.14159\\) for visual comparison. Compute standard deviation of estimates over multiple runs.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-simulation-circle-method","text":"","title":"\ud83e\udde0 Estimating \u03c0 Using Monte Carlo Simulation (Circle Method)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Monte Carlo methods estimate values using random sampling and probabilistic principles. In this method, we use a unit circle inscribed in a square to estimate the value of \u03c0.","title":"1. \ud83c\udf93 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#geometric-principle","text":"Consider a unit circle of radius 1 centered at the origin. Enclose it in a square with side length 2 (ranging from -1 to 1 on both x and y axes). Generate random points \\((x, y)\\) uniformly inside the square. Count how many points fall inside the circle using the condition: \\[ x^2 + y^2 \\leq 1 \\] The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2r)^2 = 4 \\] The ratio of the areas gives the probability that a random point falls inside the circle: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Solving for \u03c0: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points inside circle}}{\\text{Total points}} \\]","title":"\ud83d\udd37 Geometric Principle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Below is the Python code to implement this method and estimate the value of \u03c0. import numpy as np import matplotlib.pyplot as plt # Number of random points N = 10000 # Generate N random points in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Compute distance from origin for each point distance_squared = x**2 + y**2 # Count how many points fall inside the unit circle inside_circle = distance_squared <= 1 count_inside = np.sum(inside_circle) # Estimate \u03c0 pi_estimate = 4 * count_inside / N print(f\"Estimated \u03c0 \u2248 {pi_estimate}\") # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) plt.gca().add_patch(circle) plt.axhline(0, color='gray', linestyle='--') plt.axvline(0, color='gray', linestyle='--') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (N={N})\") plt.legend() plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image, display # Generate N random points N = 1000 step = 10 # number of points added per frame x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) distance_squared = x**2 + y**2 inside_circle = distance_squared <= 1 # Setup figure fig, ax = plt.subplots(figsize=(6, 6)) sc_inside = ax.scatter([], [], color='deepskyblue', s=6, alpha=0.7, label='Inside Circle') sc_outside = ax.scatter([], [], color='crimson', s=6, alpha=0.7, label='Outside Circle') # Add unit circle circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2) ax.add_patch(circle) # Format plot ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_aspect('equal') ax.set_xlabel(\"x\", fontsize=12) ax.set_ylabel(\"y\", fontsize=12) ax.set_title(\"Monte Carlo Estimation of \u03c0\", fontsize=14) ax.legend(loc='upper right', fontsize=10) ax.grid(True) # Update function for animation def update(frame): idx = (frame + 1) * step x_in = x[inside_circle][:idx] y_in = y[inside_circle][:idx] x_out = x[~inside_circle][:idx] y_out = y[~inside_circle][:idx] sc_inside.set_offsets(np.column_stack((x_in, y_in))) sc_outside.set_offsets(np.column_stack((x_out, y_out))) total = len(x_in) + len(x_out) pi_estimate = 4 * len(x_in) / total if total > 0 else 0 ax.set_title(f\"Monte Carlo Estimation of \u03c0\\nPoints: {total}, \u03c0 \u2248 {pi_estimate:.5f}\", fontsize=14) # Create animation frames = N // step ani = FuncAnimation(fig, update, frames=frames, interval=50, repeat=False) # Save the animation as a GIF ani.save(\"monte_carlo_pi.gif\", writer=PillowWriter(fps=20)) # Display the GIF inline display(Image(filename=\"monte_carlo_pi.gif\"))","title":"2. \ud83e\uddea Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"We used uniform random sampling within a square to approximate the value of \u03c0. The ratio of points inside the circle to the total number gives us a way to estimate \u03c0 using: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points inside}}{\\text{Total points}} \\] Increasing the number of points improves the accuracy due to the law of large numbers .","title":"\u2705 Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation-buffons-needle-problem","text":"","title":"\ud83e\udde0 Theoretical Foundation: Buffon\u2019s Needle Problem"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-setup","text":"Buffon\u2019s Needle is a classic probability problem posed by Georges-Louis Leclerc, Comte de Buffon in the 18th century. It presents a simple yet profound way to estimate the value of \\(\\pi\\) using randomness and geometry. Imagine a plane with equally spaced parallel lines a distance \\(t\\) apart. A needle of length \\(L\\) (where \\(L \\leq t\\) ) is randomly dropped onto this plane. We repeat this process \\(N\\) times and observe how many times the needle crosses a line. This stochastic process can be used to estimate the value of \\(\\pi\\) based on the probability of a crossing .","title":"\ud83d\udcd6 Problem Setup"},{"location":"1%20Physics/6%20Statistics/Problem_2/#derivation-of-the-formula","text":"Let: - \\(L\\) = length of the needle - \\(t\\) = distance between lines (assume \\(L \\leq t\\) ) - \\(N\\) = number of needle drops - \\(C\\) = number of times the needle crosses a line The probability that a single needle will cross a line is given by: \\[ P = \\frac{2L}{t\\pi} \\] Hence, if we drop \\(N\\) needles and observe \\(C\\) crossings, we estimate \\(P \\approx \\frac{C}{N}\\) . Rearranging the equation to solve for \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} \\]","title":"\ud83e\uddee Derivation of the Formula"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-steps","text":"To perform the Monte Carlo simulation of Buffon\u2019s Needle: Randomly drop \\(N\\) needles : For each needle, generate: A random distance from the center of the needle to the nearest line: $$ y \\in [0, t/2] $$ A random angle \\(\\theta\\) between the needle and the parallel lines: $$ \\theta \\in [0, \\pi/2] $$ Determine if a needle crosses a line : A needle crosses a line if the vertical projection from its center exceeds \\(y\\) , i.e.: $$ \\frac{L}{2} \\sin(\\theta) \\geq y $$ Count the number of crossings \\(C\\) . Estimate \\(\\pi\\) using the derived formula: $$ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} $$","title":"\ud83d\udee0\ufe0f Simulation Steps"},{"location":"1%20Physics/6%20Statistics/Problem_2/#important-notes","text":"For accurate results, ensure \\(L \\leq t\\) . The larger the number of trials \\(N\\) , the more accurate the approximation of \\(\\pi\\) becomes. Buffon's Needle illustrates the deep connection between geometry , probability , and mathematical constants like \\(\\pi\\) .","title":"\ud83d\udccc Important Notes"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization-of-buffons-needle-simulation","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from matplotlib.animation import PillowWriter # Parameters L = 0.9 # Needle length t = 1.0 # Distance between lines N = 200 # Number of needle drops line_count = 10 # Number of parallel lines # Generate random needle centers and angles x_centers = np.random.uniform(0, line_count, N) y_centers = np.random.uniform(0, line_count, N) angles = np.random.uniform(0, np.pi, N) # Calculate needle endpoints dx = (L / 2) * np.cos(angles) dy = (L / 2) * np.sin(angles) x1 = x_centers - dx x2 = x_centers + dx y1 = y_centers - dy y2 = y_centers + dy # Determine crossings crossings = (np.floor(y1 / t) != np.floor(y2 / t)) # Set up figure and axes fig, ax = plt.subplots(figsize=(8, 8)) # Initialize plot def init(): ax.set_xlim(0, line_count) ax.set_ylim(0, line_count) ax.set_aspect('equal') ax.set_xlabel(\"x-position\") ax.set_ylabel(\"y-position\") ax.set_title(\"Buffon's Needle Simulation\\nGreen = Crosses Line, Red = Doesn't Cross\", fontsize=14) ax.grid(True) for i in range(line_count + 1): ax.axhline(i * t, color='gray', linestyle='--', linewidth=1) return [] # Update function for animation def update(frame): color = 'green' if crossings[frame] else 'red' ax.plot([x1[frame], x2[frame]], [y1[frame], y2[frame]], color=color, alpha=0.7) return [] # Create animation ani = animation.FuncAnimation(fig, update, frames=N, init_func=init, blit=False, interval=50, repeat=False) # Save as GIF gif_path = \"/content/buffon_simulation.gif\" ani.save(gif_path, writer=PillowWriter(fps=20)) print(\"GIF saved to:\", gif_path)","title":"\ud83c\udfa8 Visualization of Buffon's Needle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#geometric-representation","text":"To visually understand how Buffon\u2019s Needle estimates \u03c0, we simulate and plot: Equally spaced parallel lines a distance \\(t\\) apart, running horizontally. Randomly dropped needles , each with: A center point \\((x, y)\\) within the simulation area. A random orientation angle \\(\\theta\\) . Two endpoints computed using: $$ \\text{end}_1 = \\left(x - \\frac{L}{2} \\cos\\theta,\\ y - \\frac{L}{2} \\sin\\theta\\right) $$ $$ \\text{end}_2 = \\left(x + \\frac{L}{2} \\cos\\theta,\\ y + \\frac{L}{2} \\sin\\theta\\right) $$","title":"\ud83d\uddbc\ufe0f Geometric Representation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visual-features","text":"Parallel lines : drawn as horizontal gray or black lines at \\(y = nt\\) for integer \\(n\\) . Needles that cross a line : Highlighted in green . Needles that do not cross : Shown in red or another contrasting color. Use alpha transparency and thin lines to reduce visual clutter.","title":"\ud83d\udd0d Visual Features"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis-of-estimation-accuracy","text":"","title":"\ud83d\udcca Analysis of Estimation Accuracy"},{"location":"1%20Physics/6%20Statistics/Problem_2/#effect-of-number-of-drops-n","text":"As with many Monte Carlo methods, the accuracy of the \u03c0 estimate improves with more trials: For small \\(N\\) , the estimate fluctuates significantly due to randomness. For large \\(N\\) , the estimate converges slowly toward the true value of \\(\\pi\\) . The convergence is statistical and exhibits variance , roughly decreasing with: $$ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} $$","title":"\ud83d\udcc8 Effect of Number of Drops (\\(N\\))"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-to-circle-based-monte-carlo","text":"Feature Buffon\u2019s Needle Circle Method Geometry Lines and needles Square and inscribed circle \u03c0 Formula \\(\\pi \\approx \\frac{2L \\cdot N}{t \\cdot C}\\) \\(\\pi \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}}\\) Convergence Rate Slow Moderate Visual Intuition Strong Very strong Computational Simplicity Moderate High Accuracy (at same \\(N\\) ) Typically lower Typically higher","title":"\ud83d\udd01 Comparison to Circle-Based Monte Carlo"},{"location":"1%20Physics/6%20Statistics/Problem_2/#recommendations","text":"Use Buffon\u2019s method to teach geometric probability . For practical Monte Carlo \u03c0 estimation, prefer the circle method for faster convergence and simpler implementation. Combine visual outputs with \u03c0 vs. \\(N\\) convergence plots for deeper insight.","title":"\ud83d\udccc Recommendations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#optional-extensions","text":"Plot a curve showing \\(\\pi\\) estimates as a function of \\(N\\) . Overlay a line showing the true value \\(\\pi \\approx 3.14159\\) for visual comparison. Compute standard deviation of estimates over multiple runs.","title":"\ud83d\udcc9 Optional Extensions"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}